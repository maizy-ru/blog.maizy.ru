<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>blog.maizy.ru</title><link href="http://blog.maizy.ru/" rel="alternate"></link><link href="http://blog.maizy.ru.local/feeds/all/atom.xml" rel="self"></link><id>http://blog.maizy.ru/</id><updated>2015-07-20T00:00:00+03:00</updated><entry><title>Akka для распределённых приложений - remote vs cluster</title><link href="http://blog.maizy.ru/posts/akka-remote-n-cluster" rel="alternate"></link><updated>2015-07-20T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-07-20:posts/akka-remote-n-cluster</id><summary type="html">&lt;p&gt;Буду делать небольшие заметки на полях по результатам изучения akka.&lt;/p&gt;
&lt;p&gt;Akka – это система акторов на jvm, реализованная на scala. Можно использовать и из java. Про саму концепцию акторов можно почитать в &lt;a href="https://ru.wikipedia.org/wiki/Модель_акторов"&gt;интернетах&lt;/a&gt;, здесь я буду останавливаться на особенностях akka.&lt;/p&gt;
&lt;h3&gt;Что читать?&lt;/h3&gt;
&lt;p&gt;Я пока рекомендую такие источники:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://akka.io/docs/"&gt;официальная документация&lt;/a&gt; - она хорошая, содержит как теоретические основы, так и конкретные примеры кода и описания API. Можно читать из начала в конец, как книгу. Есть &lt;a href="http://doc.akka.io/docs/akka/2.3.12/AkkaScala.pdf"&gt;pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"Akka in Action" by Raymond Roestenburg, Rob Bakker, and Rob Williams - неплохая книга. Я читаю 16 MEAP (early access), к осени-зиме 2015 обещают релиз. &lt;a href="http://www.manning.com/roestenburg/"&gt;Цена 40$&lt;/a&gt;. В основном ориентируюсь на документацию, но в книге  плюс - итеративный подход к реализации демо проекта. Начинают с hello world'ов и далее по нарастающей. Было полезно, когда хотелось быстрого старта без изучения всех тонкостей теории.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stack Overflow - как всегда стоит делать аккуратно. Фреймворк активно развивается, некоторые вещи появляются, которые раньше нужно было самому велосипедить, некоторые становятся deprecated и пр., но есть не мало полезных объяснений.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Googling по тонким вопросам и непоняткам, который нередко приводит в google группу akka.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если жалко 40$, то книгу можно не покупать. Благородя Typesafe хайпа в сети по akka хватает. Для фреймворка – это хорошо.&lt;/p&gt;
&lt;h3&gt;Применимость&lt;/h3&gt;
&lt;p&gt;Меня akka интересует в основном с точки зрения распределённых систем.
Akka позволяет работать на одной jvm и даже есть &lt;a href="http://engineering.intenthq.com/2015/06/wikidata-akka-streams/"&gt;успешные кейсы&lt;/a&gt;, когда в такой подход даёт выигрыш в противовес обычным многопоточным потокам.&lt;/p&gt;
&lt;p&gt;При этом в akka имеет грамотный подход, что реализации работы различных механизмов по сети ставиться во главу угла, а локальная работа рассматривается, как один из способов оптимизации.&lt;/p&gt;
&lt;h3&gt;remote vs cluster&lt;/h3&gt;
&lt;p&gt;В akka есть понятие "&lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/remoting.html"&gt;akka remote&lt;/a&gt;" – это возможность работать с любыми акторами прозрачно, не зная, где именно они находятся - локально или удалённо. Вы должны каким-либо образом знать, как до этих акторов добраться и эта реализация на вашей ответственности.&lt;/p&gt;
&lt;p&gt;Поверх akka remote строиться &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html"&gt;akka cluster&lt;/a&gt;, который реализует кластерное решение, т.е. количество нод может динамически меняться, каждой ноде может быть назначена роль, которую она исполняет в системе.&lt;/p&gt;
&lt;p&gt;Ноды договариваются с друг другом по &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#Gossip"&gt;gossip протоколу&lt;/a&gt; и внутри используют для хранения состояния CRDT структуры. Одна из нод назначается мастером, если она погасла мастером станет автоматически другая нода.&lt;/p&gt;
&lt;p&gt;Гашение нод вы определяете сами, система только говорит, что нода стала не доступна, вы сами можете решить, что делать - удалять её из кластера или нет. Есть стандартная реализация, когда нода удаляется после недоступности в течении какого-то времени.&lt;/p&gt;
&lt;p&gt;На события кластера, или более точно на жизненный цикл его нод, &lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/cluster-usage.html#A_Simple_Cluster_Example"&gt;можно подписаться&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Некоторые вещи в akka cluster ещё только в &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#niy"&gt;планах на реализацию&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Нет встроенного механизма сказать кластеру "я запустился", у ноды при старте должен быть список seed нод, хотя бы одна из которых должна работать. Seed нодой может быть любая нода работающего кластера. Т.е. в реальной жизни тут нужно будет брать какие-то решения для discovery. Как вариант предлагают также держать ноды, которые ничего не делают (не запускают пользовательские акторы), а только используются как seed ноды.&lt;/p&gt;
&lt;p&gt;Пока всё. Некоторые из аспектов описанных выше я буду изучать подробнее и ещё про них напишу. Если найдёте в моих записях ошибки, буду раз замечаниям.&lt;/p&gt;</summary><category term="akka"></category></entry><entry><title>Отличие Future от Promise</title><link href="http://blog.maizy.ru/posts/future-vs-promise" rel="alternate"></link><updated>2015-04-13T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-04-13:posts/future-vs-promise</id><summary type="html">&lt;p&gt;Недавно пытался на пальцах объяснить отличие Future от Promise. Понятия эти очень близкие, даже &lt;a href="http://en.wikipedia.org/wiki/Futures_and_promises"&gt;статья на Wikipedia&lt;/a&gt; про них одна.&lt;/p&gt;
&lt;p&gt;Как правило Future и Promise используются как контейнер, для представления данных, которых пока нет, но уже можно сформировать цепочку их обработки. Реализации, которые мне известны: &lt;a href="https://twistedmatrix.com/documents/14.0.1/core/howto/defer.html"&gt;Deffered в Twisted&lt;/a&gt;, &lt;a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects"&gt;Future в python 3&lt;/a&gt;, его &lt;a href="http://www.tornadoweb.org/en/branch3.2/concurrent.html?highlight=future#tornado.concurrent.Future"&gt;примитивный backport в tornado&lt;/a&gt; и &lt;a href="https://api.jquery.com/category/deferred-object/"&gt;Deffered в jQuery&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Мне нравится такое определение разницы:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Future&lt;/strong&gt; – это контейнер, на результат которого вы &lt;em&gt;подписываетесь&lt;/em&gt;, но не управляете его появлением.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt; – это контейнер, результат в который вы &lt;em&gt;предоставляете&lt;/em&gt; и сами управляете его появлением в будущем.&lt;/p&gt;
&lt;p&gt;Условно можно считать Future "переменной", а Promise "функцией по установке переменной". Логично, что во многих реализациях эти объекты порождаются парами. Иногда даже эти понятия смешивают в один контейнер, который предоставляет реализации обоих задач, например, так сделано в jQuery и python. Но даже, если реализация смешана, полезно каким-либо образом, хотя бы в соглашениях понимать имеете ли вы право "зажечь" контейнер или имеете право только подписываться на него.&lt;/p&gt;
&lt;p&gt;За Future не нужно следить и можно считать, что код который их вернул обязательно когда-нибудь вызовет ваши callback'и. За Promise же вы ответственны и должны не забыть вызвать его в любом случае, даже если ваш код упал с какой-то ожидаемой или не ожидаемой ошибкой.&lt;/p&gt;</summary><category term="async"></category></entry><entry><title>Использование ansible в Docker контейнерах</title><link href="http://blog.maizy.ru/posts/ansible-in-docker" rel="alternate"></link><updated>2015-04-02T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-04-02:posts/ansible-in-docker</id><summary type="html">&lt;p&gt;Для решения задачи настройки сервера уже давно придумали много вещей лучше, чем просто bash скрипт. Я в частности, использую &lt;a href="http://docs.ansible.com/index.html"&gt;ansible&lt;/a&gt;. Но для создания docker контейнеров &lt;a href="https://docs.docker.com/reference/builder/"&gt;по прежнему предлагается&lt;/a&gt; механизм который не далеко ушёл от bash скриптов.&lt;/p&gt;
&lt;p&gt;Мне понадобилось строить на сервере набор контейнеров, причём полностью автоматизировано. Если создание docker images на основе Dockerfile и работа с готовыми контейнерами в ansible решается из коробки, то с настройкой контейнеров через ansible пришлось немного извратиться.&lt;/p&gt;
&lt;p&gt;Идея простая:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;сделать базовый image в docker в котором через Dockerfile устанавливается только ansible,&lt;/li&gt;
&lt;li&gt;засинхронизировать с локальной машины на хост машину все файлы, нужные для ansible - роли, настройки и таски,&lt;/li&gt;
&lt;li&gt;создать контейнер,&lt;/li&gt;
&lt;li&gt;засинхронизированные настройки подключить в volume внутри контейнера,&lt;/li&gt;
&lt;li&gt;запустить ansible-playbook через docker exec,&lt;/li&gt;
&lt;li&gt;готовые контейнеры при необходимости коммитяться и используются как основа для других контейнеров.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Плюсы ansible здесь – идемпотентность, готовые модули и возможность использовать некоторые роли, как для хост машин, так и для контейнеров. Например, у меня есть абстрактная роль &lt;code&gt;nginx&lt;/code&gt; и отдельная роль поверх неё &lt;code&gt;nginx_container&lt;/code&gt; со спецификой для контейнеров.&lt;/p&gt;
&lt;p&gt;То что получилось и подробности работы можно посмотреть в &lt;a href="https://github.com/scala-moscow/deploy"&gt;репозитории scala-moscow/deploy&lt;/a&gt;.&lt;/p&gt;</summary><category term="ansible"></category><category term="docker"></category></entry><entry><title>Почему я завёл этот блог.</title><link href="http://blog.maizy.ru/posts/why" rel="alternate"></link><updated>2015-04-02T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-04-02:posts/why</id><summary type="html">&lt;p&gt;TODO: Текст, текст.&lt;/p&gt;</summary></entry></feed>