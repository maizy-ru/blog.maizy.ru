<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>blog.maizy.ru</title><link href="http://blog.maizy.ru/" rel="alternate"></link><link href="http://blog.maizy.ru.local/feeds/tags/scala/atom.xml" rel="self"></link><id>http://blog.maizy.ru/</id><updated>2015-11-12T00:00:00+03:00</updated><entry><title>Мониторинг CO2 и работа с USB на scala</title><link href="http://blog.maizy.ru/posts/mt8057-usb-hid-scala" rel="alternate"></link><updated>2015-11-12T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-11-12:posts/mt8057-usb-hid-scala</id><summary type="html">&lt;p&gt;Озадачился мониторингом CO2 в помещениях. Сначала смотрел на отдельные датчики, думая собрать на коленке и rPi, но потом нашёл дешёвый сборный комплект &lt;a href="http://masterkit.ru/shop/others/dadget/1266110"&gt;Masterkit MT8057&lt;/a&gt;. Он настолько отличный, что с удовольствием его рекламирую.&lt;/p&gt;
&lt;p&gt;В результате у меня &lt;a href="#res"&gt;получился драйвер к MT8057 на scala и stand alone утилита&lt;/a&gt;, ниже в посте поделюсь некоторыми заметками к этой реализации.&lt;/p&gt;
&lt;h3&gt;Драйвер MT8057&lt;/h3&gt;
&lt;p&gt;Для MT8057 есть opensource реализация утилиты для съёма параметров от Олега Булатова написанная на C – &lt;a href="https://github.com/dmage/co2mon"&gt;co2mon&lt;/a&gt;. co2mon вариант хороший и рабочий, поддерживает и OS X, и Linux. Наверное, я бы справился докрутить туда выгрузку данных в InfluxDB, куда я собирался сложить все метрики, но решил пописать своих велосипедов, попрактиковаться в низкоуровневых штуках на scala и вспомнить работу с USB.&lt;/p&gt;
&lt;p&gt;В первый подход взял хороший и зрелый проект &lt;a href="http://usb4java.org/"&gt;usb4java&lt;/a&gt;, но оказалось, что с поддержкой OS X там беда. Требуются извращения типа &lt;a href="https://github.com/libusb/libusb/wiki/FAQ#How_can_I_run_libusb_applications_under_Mac_OS_X_if_there_is_already_a_kernel_extension_installed_for_the_device"&gt;выгрузки-загрузки kext'ов&lt;/a&gt;, которые у меня ещё и не завелись с первого раза.&lt;/p&gt;
&lt;p&gt;Во второй подход взял &lt;a href="https://github.com/gary-rowe/hid4java"&gt;hid4java&lt;/a&gt;, этот продукт хоть и анонсируется, как годный к production использованию, ещё достаточно сырой. Шаг влево, шаг вправо и ловишь jvm crash где-то в кишках интеграции с C-шной библиотекой. Написан через &lt;a href="https://github.com/java-native-access/jna"&gt;JNA&lt;/a&gt;, внутри лежат скомпилированные библиотеки для Linux x86_64, Linux ARM, OS X и ещё нескольких платформ. На OS X работает без всяких танцев с kext'ами. Из проблем – API не очень удобный, хуки вызываются из каких попало тредов, у меня это обходится с помощью обёртки с потокобезопасной очередью. Часть методов работает как бы правильно, возвращает правильные Java объекты, но при попытке что-то вызвать у этого объекта получаешь ошибку или crash, так что пришлось &lt;a href="https://github.com/maizy/ambient7/blob/41e6b92a9ca21769d6e9c7c5a47868d1740f8b5a/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MT8057Service.scala#L99-L101"&gt;добавить костыль&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;HID это отдельный класс USB устройств, поэтому не всегда будет выбор между этими библиотеками, в частности usb4java (а вернее libusb) ничего про HID &lt;a href="http://www.libusb.org/wiki/APIs#libusb-1.0currentAPIandimplementation"&gt;не знает и знать не собирается&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Scala для работы с байтами&lt;/h3&gt;
&lt;p&gt;В scala всё просто и удобно. Массивы java типа &lt;code&gt;byte[]&lt;/code&gt; в Scala превращаются в &lt;code&gt;Array[Byte]&lt;/code&gt;. Вооружившись в добавок &lt;code&gt;scala.collection.JavaConversions&lt;/code&gt; можно писать привычный scala код.&lt;/p&gt;
&lt;p&gt;Внутри драйвера есть &lt;a href="https://github.com/maizy/ambient7/blob/master/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MessageDecoder.scala"&gt;зубодробительный код с распаковкой данных&lt;/a&gt; от MT8057 и всё это неплохо легло в scala код, местами даже функциональный.&lt;/p&gt;
&lt;p&gt;&lt;a name="res"/&gt;&lt;/p&gt;
&lt;h3&gt;Результат&lt;/h3&gt;
&lt;p&gt;На выходе у меня получился драйвер MT8057 и декодер к HID пакетам с данными. В отдельный артефакт я их не выделял, но при необходимости это можно сделать.&lt;/p&gt;
&lt;p&gt;Про драйвер можно ничего не знать и использовать готовую утилиту &lt;a href="https://github.com/maizy/ambient7#mt8057-agent"&gt;ambient7-mt8057-agent&lt;/a&gt; которая из зависимостей требует только jre 1.6+ и пока умеет выводить данные в stdout/stderr (для записи в текстовый лог) или работать в интерактивном режиме с ANSI цветами в консоле. На подходе ещё возможность писать в InfluxDB. Готовый jar можно &lt;a href="https://github.com/maizy/ambient7#download"&gt;скачать в github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Про InfluxDB, если удастся с ним подружиться, расскажу отдельно.&lt;/p&gt;</summary><category term="scala"></category><category term="hardware"></category><category term="ambient7"></category></entry><entry><title>Шаблонизация с handlebars и json4s на scala</title><link href="http://blog.maizy.ru/posts/handlerbars-templates-in-scala" rel="alternate"></link><updated>2015-10-28T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-10-28:posts/handlerbars-templates-in-scala</id><summary type="html">&lt;p&gt;Занимаюсь неспешно своим проектом &lt;a href="https://github.com/scala-moscow/"&gt;scala.moscow&lt;/a&gt;. Одна из задач – примитивный генератор статических сайтов. Очень хотелось чего-то простого для шаблонизации. Думал взять mustache, но оказалось, что это уже не совсем модно-молодёжно, так как есть его расширения handlebars и hogan.&lt;/p&gt;
&lt;p&gt;Handlebars мне больше приглянулся. Для scala есть нативная реализация на парсер комбинаторах
&lt;a href="https://github.com/mwunsch/handlebars.scala"&gt;handlebars.scala&lt;/a&gt; и её &lt;a href="https://github.com/gilt/handlebars.scala.fork"&gt;форк&lt;/a&gt;. По фичам scala реализация очень ограничена, в частности, нет встроенной поддержки наследования шаблонов, которая в handlebars делается не силами шаблонизатора, а силами helper'ов. В итоге взял &lt;a href="https://github.com/jknack/handlebars.java"&gt;handlebars.java&lt;/a&gt;, который выглядит достаточно зрелым и имеет в составе, как минимум, helper'ы &lt;code&gt;partial&lt;/code&gt; и &lt;code&gt;block&lt;/code&gt; для наследования и i18n.&lt;/p&gt;
&lt;p&gt;После выбора шаблонизатора встал вопрос как в него загружать данные. Встроенные резолверы не удобно использовать в scala, да и хотелось чего-то более простого, чем создания пачки классов-контейнеров для данных. А что есть проще для описания примитивных структур данных, чем JSON. Для scala нашёлся отличный DSL для JSON - &lt;a href="http://json4s.org/"&gt;json4s&lt;/a&gt;, у которого в частности есть такой лаконичный DSL:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.json4s.JsonDSL._&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;copyright&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;year&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2015&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;assets&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;path&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/assets&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;scala.moscow&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;about&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;about&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;scala.moscow :: о проекте&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Плюс к этому handlebars и задумывался для комбинации с JSON, что отражается в его синтаксисе. Плюс к этому сразу решается вопрос, где хранить статические данные, которые не нужно генерить программно –  в JSON файлах. В json4s конечно есть не только DSL, но и парсеры на основе нативной scala реализации и jackson.&lt;/p&gt;
&lt;p&gt;Чтобы подружить handlebars.java и json4s DSL, написал &lt;a href="https://github.com/scala-moscow/scala.moscow/blob/master/site-generator/src/main/scala/moscow/scala/sitegen/utils/template/JValueResolver.scala"&gt;ValueResolver&lt;/a&gt;, идею и часть реализации подсмотрел у &lt;a href="https://github.com/mfirry/handlebars-json4s/"&gt;handlebars-json4s&lt;/a&gt;, но доработал её, решил часть проблем и дописал тестов. Как решу &lt;a href="https://github.com/scala-moscow/scala.moscow/blob/4d31fad70f7bccd8097de21637f820375af41b52/site-generator/src/test/scala/moscow/scala/sitegen/tests/utils/template/JValueResolverSpec.scala#L86-L93"&gt;оставшиеся проблемы&lt;/a&gt; планирую сделать отдельный артефакт.&lt;/p&gt;</summary><category term="scala"></category><category term="scala.moscow"></category></entry><entry><title>Akka. Тестирование в общем и про тестирование кластера в частности</title><link href="http://blog.maizy.ru/posts/akka-cluster-testing" rel="alternate"></link><updated>2015-09-21T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-09-21:posts/akka-cluster-testing</id><summary type="html">&lt;p&gt;Продолжая заниматься &lt;a href="https://github.com/maizy/akka-cluster-heartbeat"&gt;hello world'ом на akka&lt;/a&gt; погрузился в вопрос тестирования акторов.&lt;/p&gt;
&lt;p&gt;Общие вещи просты, не вижу смысла пересказывать &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html"&gt;документацию&lt;/a&gt;, остановлюсь только на ключевых моментах и выводах.&lt;/p&gt;
&lt;h3&gt;Асинхронное vs синхронное тестирование&lt;/h3&gt;
&lt;p&gt;Есть два подхода &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Synchronous_Unit_Testing_with_TestActorRef"&gt;синхронное&lt;/a&gt; и &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Asynchronous_Integration_Testing_with_TestKit"&gt;асинхронное&lt;/a&gt; тестирование. Первое в реальной жизни почти никогда не нужно, если только не хочется протестировать какие-то уж совсем внутренние кишки актора. В остальных случаях, лучше тестировать честно, отправляя и принимая ответы от акторов.&lt;/p&gt;
&lt;h3&gt;TestProbe и TestActor&lt;/h3&gt;
&lt;p&gt;Часть которую важно понимать. Сначала я думал, что при тестировании будет какая-то чёрная магия, которая позволит мне получать сообщения, летающие между разными акторами.&lt;/p&gt;
&lt;p&gt;На деле всё проще. Внутри вашего TestCase создаётся TestProbe и TestActor, которые затем используются для запросов к акторам и анализа приходящих результатов. К сожалению, в документации сразу показывается пример с trait &lt;code&gt;ImplicitSender&lt;/code&gt;, который слегка "гримирует" наличие testActor, что вызвало по началу повышенное количество wtf-per-line.&lt;/p&gt;
&lt;p&gt;Соответственно &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Built-In_Assertions"&gt;набор стандартных assert'ов&lt;/a&gt; на самом деле вызывается у стандартного TestProbe. Конечно же таких TestProbe можно даже &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Using_Multiple_Probe_Actors"&gt;создать несколько&lt;/a&gt; и, например, поместить в них дополнительные специфичные вам assert'ы.&lt;/p&gt;
&lt;p&gt;Отсюда же вывод, что для тестирования parent-child взаимодействия придётся вставлять между ними тестовый актор с проксированием сообщений, в документации &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Testing_parent-child_relationships"&gt;описаны способы сделать это&lt;/a&gt;. В любом случае production код нужно немного к такому подготовить, другой вопрос, что изменения полезны и для других целей.&lt;/p&gt;
&lt;h3&gt;Cluster testing&lt;/h3&gt;
&lt;p&gt;С тестированием кластерных конфигурацию всё не так тривиально.&lt;/p&gt;
&lt;p&gt;Для начала есть решение &lt;a href="https://github.com/sbt/sbt-multi-jvm"&gt;multi-jvm тестирования с плагином для sbt&lt;/a&gt;, в документации к akka описано как &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html"&gt;это всё подружить с тестами&lt;/a&gt;, чтобы &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html"&gt;получить Multi Node Testing&lt;/a&gt;. Пригодится и для других задач, когда используется просто akka remote.&lt;/p&gt;
&lt;p&gt;Печалит, что нужно &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html#multi-jvm-testing"&gt;серьёзно "испортить" конфиг sbt&lt;/a&gt;, но, наверное, можно решить выносом таких тестов в отдельный sbt проект. Также ваша IntelliJ IDEA по понятным причинам про такие тесты ничего знать не будет, так как всё магия работает только в связке с sbt. Думаю, в ScalaIDE будет аналогично.&lt;/p&gt;
&lt;p&gt;Простого способа дебажить это тоже нет. Логи не очень удобны, так как валяться в параллель со всех JVM. В идеале нужно писать обёртки, которые будут собирать их по каждой ноде отдельно.&lt;/p&gt;
&lt;h3&gt;"... напоминает мне игру: "Что? Где? Когда?" называется! Непонятно, что где валяется и когда все это кончится!"&lt;/h3&gt;
&lt;p&gt;Общерекомендуемый подход писать multi-jvm тесты в одном классе, который будет одинаково выполняться на всех нодах. Это обязывает постоянно следить за тем какой код и где исполняется. Например, написанный в лоб assert будет выполнен на всех нодах, часть из которых может быть ещё не присоединена к кластеру.&lt;/p&gt;
&lt;p&gt;Постоянно об это спотыкался, но потом написал себе пару удобных утилиток:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.collection.mutable&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.scalatest.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;BeforeAndAfterAll&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Matchers&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.Cluster&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.ClusterEvent.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;CurrentClusterState&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.remote.testconductor.RoleName&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.remote.testkit.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeConfig&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpecCallbacks&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.testkit.ImplicitSender&lt;/span&gt;



&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeBaseSpec&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;MultiNodeConfig&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpec&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;BeforeAndAfterAll&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpecCallbacks&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;ImplicitSender&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Matchers&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;beforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;beforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;multiNodeSpecBeforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;afterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before-clean-up&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;cleanUp&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;clean-up&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;multiNodeSpecAfterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;afterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Cluster&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Cluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testActor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
  &lt;span class="n"&gt;expectMsgClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;CurrentClusterState&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myself address: ${node(myself).address}, role: ${myself.name}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mutable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;]()&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;joinToCluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Seq&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;seedNode&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="o"&gt;++=&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;
    &lt;span class="c1"&gt;// on new nodes await events for all cluster member&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;cluster&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seedNode&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiveN&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;
        &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;contain&lt;/span&gt; &lt;span class="n"&gt;theSameElementsAs&lt;/span&gt; &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// on existing nodes await events for only new cluster members&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiveN&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;
        &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;contain&lt;/span&gt; &lt;span class="n"&gt;theSameElementsAs&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;join-&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;mkString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;runOnJoinedNodes&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;a&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cleanUp&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unsubscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testActor&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В базовом spec'е выше реализовано:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;подписывание на события кластера&lt;/li&gt;
&lt;li&gt;метод &lt;code&gt;joinToCluster&lt;/code&gt; для правильного присоединения к кластеру нод&lt;/li&gt;
&lt;li&gt;метод &lt;code&gt;runOnJoinedNodes&lt;/code&gt; для выполнения кода на уже работающих нодах кластера, аналогичный по использованию &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html#A_Multi_Node_Testing_Example"&gt;встроенному &lt;code&gt;runOn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Тестирование сети&lt;/h3&gt;
&lt;p&gt;Есть встроенная поддержка тестирования транспорта и сети с возможностью эмуляции проблем между нодами (blackhole). При этом я надеюсь как-нибудь попробовать приспособить docker, его API и iptables для данных целей, благо multi-jvm, кажется умеет сам в тестах упаковывать тестовую ноду в jar, раскладывать через ssh+rsync, а затем запускать.&lt;/p&gt;
&lt;h3&gt;Примеры&lt;/h3&gt;
&lt;p&gt;Можно глянуть, что &lt;a href="https://github.com/maizy/akka-cluster-heartbeat/tree/master/src/multi-jvm/scala"&gt;получилось у меня&lt;/a&gt;. Много полезных примеров я обнаружил в &lt;a href="https://github.com/akka/akka/tree/master/akka-cluster/src/multi-jvm/scala/akka/cluster"&gt;самих исходниках akka&lt;/a&gt; и &lt;a href="https://github.com/jboner/akka-crdt/tree/master/src/multi-jvm/scala/akka/crdt/convergent"&gt;в проекте akka crdt&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Вывод&lt;/h3&gt;
&lt;p&gt;Тестировать akka, даже в сложных конфигурациях можно и нужно, но tooling ещё требует доработки.&lt;/p&gt;</summary><category term="akka"></category><category term="scala"></category></entry><entry><title>FPConf 2015 - заметки на полях</title><link href="http://blog.maizy.ru/posts/fpconf-2015" rel="alternate"></link><updated>2015-08-17T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-08-17:posts/fpconf-2015</id><summary type="html">&lt;p&gt;Побывал на конференции &lt;a href="http://fpconf.ru/"&gt;FPConf&lt;/a&gt;. Поделюсь своими мыслями, возникшими при прослушивании докладов. Я в основном сидел на втором потоке, где было про scala, UI и пр. Первый поток был преимущественно про Erlang и Haskell.&lt;/p&gt;
&lt;p&gt;Организаторы обещали, что будет видео, надеюсь пополнить эту статью ссылкам в будущем.&lt;/p&gt;
&lt;h3&gt;Cамурайский путь молодого scala-программиста, Сергей Лобин, Sputnik.ru&lt;/h3&gt;
&lt;p&gt;В докладе было мало про scala, больше про проблемы при разработки геокодера в Спутнике. Главный печальный для всех фанатов Scala вывод – Scala в production и них не прижилась, найти разработчиков сложно, Go разработчиков найти значительно проще.&lt;/p&gt;
&lt;h3&gt;Макросы scala, Михаил Муцянко, JetBrains&lt;/h3&gt;
&lt;p&gt;Хороший вводный доклад про макросы Scala от разработчика &lt;a href="http://blog.jetbrains.com/scala/"&gt;Scala plugin в IDEA&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Из запомнившегося:&lt;/p&gt;
&lt;p&gt;Удобный способ построения AST в макросе через &lt;a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html"&gt;Q интерполятор&lt;/a&gt; (квазикватирование).&lt;/p&gt;
&lt;p&gt;Килер фича, когда Михаил нажатием одной волшебной кнопки прямо в IDEA, показал как разворачивается макрос в Scala код. К сожалению оказалось, что это не из production версии плагина и вроде ожидать такое в ближайшее время не стоит, так как работает не всегда корректно. Очень вкусная возможность, будем ждать.&lt;/p&gt;
&lt;p&gt;В 2.12 ожидается значительное улучшение в деле разработки макросов за счёт нового проекта &lt;a href="http://scalameta.org/"&gt;ScalaMeta&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Хорошая ссылка на изучение: What Are Macros Good For? от Евгения Бурмако &lt;a href="http://www.youtube.com/watch?v=4Rxo_7lrb7Y"&gt;YouTube&lt;/a&gt;, &lt;a href="http://scalamacros.org/paperstalks/2013-07-17-WhatAreMacrosGoodFor.pdf"&gt;слайды&lt;/a&gt;. BTW про самого Евгения и его работу над Scala макросами можно узнать в &lt;a href="http://eax.me/eaxcast-s02e10/"&gt;EaxCast S02E10&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Доклад рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;Встраивание языка в строковой интерполятор, Михаил Лиманский, ЭСК&lt;/h3&gt;
&lt;p&gt;Хороший практический доклад, как вместо DSL порой можно обойтись интерполятором. Какие возможности, плюсы и минусы такого подхода. Можно прямо брать доклад и писать свой интерполятор как по tutorial'у.&lt;/p&gt;
&lt;p&gt;В качестве домашнего задания для себя запомнил задачу реализовать интерполятор для типобезопасного форматирования строки. Хотим с &lt;a href="http://habrahabr.ru/users/aveic/"&gt;aveic&lt;/a&gt; попробовать независимо друг от друга реализовать это и посмотреть, что получиться.&lt;/p&gt;
&lt;p&gt;Рекомендую для тех, кто интересуется темой.&lt;/p&gt;
&lt;h3&gt;Lenses And Prisms, Эдвард Кметт&lt;/h3&gt;
&lt;p&gt;Самый звёздный докладчик на конференции. К сожалению без знания хотя бы основ синтаксиса Haskell понять что-то было сложно. Докладчик проводил доклад в потрясающей форме - выдавая как из пулемёта кучу кода на Haskell прями в vim'е.&lt;/p&gt;
&lt;p&gt;Чтобы понять что к чему, я смотрел на порт этой библиотеки на Scala - &lt;a href="https://github.com/julien-truffaut/Monocle"&gt;Monocle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В общих словах – это удобный способ изменения иммутабельных структур с возможностью написания максимально абстрактных маленьких кусочков с дальнейшим комбинированием в более сложные кусочки.&lt;/p&gt;
&lt;h3&gt;Реактивные потоки в backend-е, Алексей Романчук, 2ГИС&lt;/h3&gt;
&lt;p&gt;Хорошая success story про использование akka streams в production. Для меня теперь это один из ответов на вопрос «где нам нужна akka?».&lt;/p&gt;
&lt;p&gt;Забавные слайды с цветными "сосиками".&lt;/p&gt;
&lt;p&gt;Прозвучавшее число потерь на akka streams по сравнению с голыми акторами ~10%.&lt;/p&gt;
&lt;p&gt;Рекомендую всем, кому интересны akka streams.&lt;/p&gt;
&lt;h3&gt;Scala performance для сомневающихся, Роман Гребенников, Sociohub.ru&lt;/h3&gt;
&lt;p&gt;Самый запомнившийся доклад. Покрывает сразу две темы - пару примеров того как все модные молодёжные FP штуки из scala отражаются в bytecode JVM и машинном коде, какие потери они за собой несут или не несут. А также способы самому развернуть, померить и понять как выполняется тот или иной код.&lt;/p&gt;
&lt;p&gt;Вкратце про проблемы – простой pattern matching по типу параметра - также быстро как колбаса из if'ов. Есть проблемы с boxing/unboxing в Scala collection и прикладывать &lt;a href="http://www.scala-lang.org/api/2.11.4/index.html#scala.specialized"&gt;@specialized&lt;/a&gt; не поможет.&lt;/p&gt;
&lt;p&gt;Рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;В общем&lt;/h3&gt;
&lt;p&gt;Очень приятное послевкусие от конференции, не ожидал, что про FP будет так целостно. Как сказали организаторы было 180 человек.&lt;/p&gt;
&lt;p&gt;Не посмотрел в живую «Фронтэнд без грусти» Никиты Прокопова, о котором наслышан от коллег, которые видели доклад на какой-то другой конференции. А также хочется поглядеть на «Aрхитектура UI на основе функциональных линз» от Ильи Беда.&lt;/p&gt;
&lt;p&gt;Буду ждать видео.&lt;/p&gt;</summary><category term="conference"></category><category term="scala"></category></entry></feed>