<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>blog.maizy.ru - cats</title><link href="https://blog.maizy.ru/" rel="alternate"></link><link href="https://blog.maizy.ru/feeds/tags/cats/atom.xml" rel="self"></link><id>https://blog.maizy.ru/</id><updated>2018-12-21T00:00:00+03:00</updated><entry><title>Конспект по Scala with Cats</title><link href="https://blog.maizy.ru/posts/scala-cats-summary" rel="alternate"></link><published>2018-12-21T00:00:00+03:00</published><updated>2018-12-21T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2018-12-21:/posts/scala-cats-summary</id><summary type="html">&lt;p&gt;Scala with Cats – это &lt;a href="https://underscore.io/books/scala-with-cats/"&gt;свободно доступная книга&lt;/a&gt;, написанная Noel Welsh и Dave Gurnell из Underscore. Охватывает все основы использования библиотеки &lt;a href="https://typelevel.org/cats/"&gt;cats&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Книгу рекомендую читать с выполнением заданий, без этого лично мне полного понимания достичь не удалось.&lt;/p&gt;
&lt;p&gt;Ниже краткий насколько возможно конспект по Type Class'ам из книги.&lt;/p&gt;
&lt;h3&gt;Show&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;вывести на печать любой тип&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.show&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eq&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;типобезопасное сравнение&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a === b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a =!= b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monoid&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.combine(a1, a2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.empty[A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;законы:&lt;ul&gt;
&lt;li&gt;combine ассоциативный&lt;/li&gt;
&lt;li&gt;empty должен быть нейтральным элементом (identity element)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение двух значений&lt;/li&gt;
&lt;li&gt;только combine из Monoid&lt;/li&gt;
&lt;li&gt;там где требуется Semigroup, всегда можно использовать Monoid&lt;/li&gt;
&lt;li&gt;нужен так как не всегда существует нейтральный элемент, пример – NonEmptyList&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;a |+| b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Functor&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;что-то у чего есть &lt;code&gt;map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;не стоит думать об этом только, как о проходе по списку, это может быть и работа с внутренним состоянием "контейнера" (в контексте этого "контейнера"), без извлечения значения из "контейнера".&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.lift(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f.map(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Contravariant (Functor)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;из &lt;code&gt;F[B]&lt;/code&gt; имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt; получить &lt;code&gt;F[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.contramap(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Invariant&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt;, &lt;code&gt;B =&amp;gt; A&lt;/code&gt; и &lt;code&gt;Monoid[B]&lt;/code&gt; получить &lt;code&gt;Monoid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;Monoid[B].imap(f)(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1000 разных подходов к определению, в книге такое: монада – механизм для последовательных вычислений&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt; – создание монадического контекста из сырого значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; – извлечение значения из контекста и создание следующего контекста в последовательности&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;любая монада – функтор, map легко построить из pure+flatMap&lt;/li&gt;
&lt;li&gt;laws:&lt;ul&gt;
&lt;li&gt;левоассоциативность: &lt;code&gt;pure(a).flatMap(f) == f(a)&lt;/code&gt;. тут важно помнить об эффектах. именно по этой причине Try не Monad, так как если "снять" с него контекст монады при обычном вызове получим эффект – исключение, а если не снять то получим Failure.&lt;/li&gt;
&lt;li&gt;правоассоциативность: &lt;code&gt;m.flatMap(pure) == m&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;ассоциативность: &lt;code&gt;m.flatMap(f).flatMap(g) == m.flatMap(x =&amp;gt; f(x).flatMap(g))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure[T]&lt;/code&gt; (из cats.syntax.applicative)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt; (из cats.syntax.functor)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; (из cats.syntax.flatMap)&lt;/li&gt;
&lt;li&gt;можно использовать for comprehensions из scala&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;при определении своих монад&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tailRecM&lt;/code&gt; – оптимизация для вложенных .flatMap вызовов. метод можно делать &lt;code&gt;@tailrec&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Id&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Identity Monad&lt;/li&gt;
&lt;li&gt;позволяет использовать в коде, где ожидаются монады немонадные значения&lt;/li&gt;
&lt;li&gt;мощный инструмент для тестов кода построенного на монадах&lt;/li&gt;
&lt;li&gt;например&lt;ul&gt;
&lt;li&gt;&lt;code&gt;123 : Id[Int]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"abc" : Id[String]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Either&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;обычный тип из scala&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.orElse(Either)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recover(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recoverWith(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;right bias (flatMap/map/filter работающие на правой части Either, есть из коробки в scala 2.12+)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asRight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asLeft&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MonadError&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция поверх Either для работы с ошибками&lt;/li&gt;
&lt;li&gt;параметризирован типом монады и типом ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.raiseError(e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.handleError(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(a)(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eval&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция над выполнением&lt;/li&gt;
&lt;li&gt;в частности: позволяет делать стекобезопасные рекурсивные вычисления&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.now(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.later(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.always(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.memoize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.defer(=&amp;gt; Eval)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Writer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;сбор лога при вычислении&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (log, result) = writer.run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapWritten(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapBoth( (log, res) =&amp;gt; ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.reset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.pure[T]&lt;/code&gt; (требует Monoid[T] в implicit scope)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.tell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.writer(seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Reader&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;построение цепочки операций на основе входных параметров&lt;/li&gt;
&lt;li&gt;ex: DI, encoders&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt; – позволяет объединить несколько reader от одного входного значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;State&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;передача дополнительного состояния в вычисления&lt;/li&gt;
&lt;li&gt;моделирование мутабельного состояния в pure functional подходе&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State[S, A]&lt;/code&gt; это &lt;code&gt;S =&amp;gt; (S, A)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (state, res) = a.run(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runS(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runA(v).value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;стандартные преобразования&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State.get&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.inspect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.modify&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;синтаксис&lt;ul&gt;
&lt;li&gt;for comprehension&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad transformers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;позволяют комбинировать монады&lt;/li&gt;
&lt;li&gt;комбинация невозможна без знаний об одной из двух монад&lt;/li&gt;
&lt;li&gt;например, EitherT позволяет комбинировать любую монаду с Either&lt;/li&gt;
&lt;li&gt;из коробки: &lt;code&gt;cats.data.{OptionT, EitherT, ReaderT, WriterT, StateT, IdT}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;соглашение: трансформер определяет внутреннюю монаду, а первый его тип - внешнюю. например, &lt;code&gt;OptionT[List, A]&lt;/code&gt; – создаст монаду для &lt;code&gt;List[Option[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;если нужно часто определять alias для типов в стеках монад, поможет scala compiler plugin king projector. с ним можно писать так: &lt;code&gt;123.pure[EitherT[Option, String, ?]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;использование для реализации:&lt;ul&gt;
&lt;li&gt;многие монады реализованы через трансформеры&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type ReaderT[F[_], A, B] = Kleisli[F, A, B]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type Writer[W, A] = WriterT[Id, W, A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Kleisli&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение функций &lt;code&gt;A =&amp;gt; F[B]&lt;/code&gt;, &lt;code&gt;B =&amp;gt; F[C]&lt;/code&gt; в &lt;code&gt;A =&amp;gt; F[C]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroupal&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединяет два контекста&lt;/li&gt;
&lt;li&gt;в литературе иногда называют Monoidal&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.map2&lt;/code&gt; ... &lt;code&gt;.map22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tuple2&lt;/code&gt; ... &lt;code&gt;.tuple22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.contramap2&lt;/code&gt; ... &lt;code&gt;.contramap22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.imap2&lt;/code&gt; ... &lt;code&gt;.imap22&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(a, b, c, ...).tupled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a, b, c ...).mapN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(Monoid[A], Monoid[B], ...).imapN(toF)(fromF)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Intellij Idea не понимает тип выражения после mapN, это &lt;a href="https://youtrack.jetbrains.com/issue/SCL-12892"&gt;недавно поправили&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Иногда получаемый результат не сразу очевиден. Например Semigroupal от двух списков будет прямое произведение (каждый с каждым), а не zip списков.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Validated&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналог Either, но с накоплением всех ошибок&lt;/li&gt;
&lt;li&gt;требует Semigroup для типа ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Validated.valid[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.invalid[E, A](e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchOnly[Throwable](f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchNonFatal(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromTry(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromEither[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromOption[E, A](a, e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.toEither&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withEither(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withValidated(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.getOrElse(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.fold(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.valid[E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.invalid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure[Validated[F[E], A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.raiseError[Validated[F[E], A], E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tupled&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Apply&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Semigroupal + Functor&lt;/li&gt;
&lt;li&gt;альтернативный к Semigroupal способ закодировать объединение контекстов&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ap(f)(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.product(a, b)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Applicative&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Apply + pure, который позволяет создать новый Applicative instance из сырого значения&lt;/li&gt;
&lt;li&gt;Monad = Applicative + FlatMap&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;NonEmpty*&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналоги стандартных коллекций, но имеющие строго один или более элементов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyList&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyVector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Foldable&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция для foldLeft / foldRight&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.foldLeft(a, i)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldRight(a, i: Eval[B])(f): Eval[B]&lt;/code&gt; (stack safe)&lt;/li&gt;
&lt;li&gt;привычные методы коллекций, поверх foldLeft: &lt;code&gt;.find&lt;/code&gt;, &lt;code&gt;.exists&lt;/code&gt;, &lt;code&gt;.forall&lt;/code&gt;, &lt;code&gt;.toList&lt;/code&gt;, &lt;code&gt;.isEmpty&lt;/code&gt;, &lt;code&gt;.nonEmpty&lt;/code&gt; ...&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.combineAll(a)&lt;/code&gt; (aka &lt;code&gt;.fold&lt;/code&gt;, требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldMap(a)(f)&lt;/code&gt; (требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.compose(other)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;все операции доступны как синтаксис&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.foldLeft(i)(f)&lt;/code&gt; и т. д.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Traverse&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея набор из F[A], получить F от набора А&lt;/li&gt;
&lt;li&gt;например, &lt;code&gt;List[Future[A]]&lt;/code&gt; → &lt;code&gt;Future[List[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.traverse(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.sequence(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.traverse(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.sequence&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Scala with Cats – это &lt;a href="https://underscore.io/books/scala-with-cats/"&gt;свободно доступная книга&lt;/a&gt;, написанная Noel Welsh и Dave Gurnell из Underscore. Охватывает все основы использования библиотеки &lt;a href="https://typelevel.org/cats/"&gt;cats&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Книгу рекомендую читать с выполнением заданий, без этого лично мне полного понимания достичь не удалось.&lt;/p&gt;
&lt;p&gt;Ниже краткий насколько возможно конспект по Type Class'ам из книги.&lt;/p&gt;
&lt;h3&gt;Show&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;вывести на печать любой тип&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.show&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eq&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;типобезопасное сравнение&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a === b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a =!= b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monoid&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.combine(a1, a2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.empty[A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;законы:&lt;ul&gt;
&lt;li&gt;combine ассоциативный&lt;/li&gt;
&lt;li&gt;empty должен быть нейтральным элементом (identity element)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение двух значений&lt;/li&gt;
&lt;li&gt;только combine из Monoid&lt;/li&gt;
&lt;li&gt;там где требуется Semigroup, всегда можно использовать Monoid&lt;/li&gt;
&lt;li&gt;нужен так как не всегда существует нейтральный элемент, пример – NonEmptyList&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;a |+| b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Functor&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;что-то у чего есть &lt;code&gt;map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;не стоит думать об этом только, как о проходе по списку, это может быть и работа с внутренним состоянием "контейнера" (в контексте этого "контейнера"), без извлечения значения из "контейнера".&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.lift(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f.map(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Contravariant (Functor)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;из &lt;code&gt;F[B]&lt;/code&gt; имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt; получить &lt;code&gt;F[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.contramap(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Invariant&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt;, &lt;code&gt;B =&amp;gt; A&lt;/code&gt; и &lt;code&gt;Monoid[B]&lt;/code&gt; получить &lt;code&gt;Monoid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;Monoid[B].imap(f)(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1000 разных подходов к определению, в книге такое: монада – механизм для последовательных вычислений&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt; – создание монадического контекста из сырого значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; – извлечение значения из контекста и создание следующего контекста в последовательности&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;любая монада – функтор, map легко построить из pure+flatMap&lt;/li&gt;
&lt;li&gt;laws:&lt;ul&gt;
&lt;li&gt;левоассоциативность: &lt;code&gt;pure(a).flatMap(f) == f(a)&lt;/code&gt;. тут важно помнить об эффектах. именно по этой причине Try не Monad, так как если "снять" с него контекст монады при обычном вызове получим эффект – исключение, а если не снять то получим Failure.&lt;/li&gt;
&lt;li&gt;правоассоциативность: &lt;code&gt;m.flatMap(pure) == m&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;ассоциативность: &lt;code&gt;m.flatMap(f).flatMap(g) == m.flatMap(x =&amp;gt; f(x).flatMap(g))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure[T]&lt;/code&gt; (из cats.syntax.applicative)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt; (из cats.syntax.functor)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; (из cats.syntax.flatMap)&lt;/li&gt;
&lt;li&gt;можно использовать for comprehensions из scala&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;при определении своих монад&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tailRecM&lt;/code&gt; – оптимизация для вложенных .flatMap вызовов. метод можно делать &lt;code&gt;@tailrec&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Id&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Identity Monad&lt;/li&gt;
&lt;li&gt;позволяет использовать в коде, где ожидаются монады немонадные значения&lt;/li&gt;
&lt;li&gt;мощный инструмент для тестов кода построенного на монадах&lt;/li&gt;
&lt;li&gt;например&lt;ul&gt;
&lt;li&gt;&lt;code&gt;123 : Id[Int]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"abc" : Id[String]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Either&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;обычный тип из scala&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.orElse(Either)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recover(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recoverWith(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;right bias (flatMap/map/filter работающие на правой части Either, есть из коробки в scala 2.12+)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asRight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asLeft&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MonadError&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция поверх Either для работы с ошибками&lt;/li&gt;
&lt;li&gt;параметризирован типом монады и типом ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.raiseError(e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.handleError(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(a)(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eval&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция над выполнением&lt;/li&gt;
&lt;li&gt;в частности: позволяет делать стекобезопасные рекурсивные вычисления&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.now(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.later(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.always(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.memoize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.defer(=&amp;gt; Eval)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Writer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;сбор лога при вычислении&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (log, result) = writer.run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapWritten(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapBoth( (log, res) =&amp;gt; ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.reset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.pure[T]&lt;/code&gt; (требует Monoid[T] в implicit scope)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.tell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.writer(seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Reader&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;построение цепочки операций на основе входных параметров&lt;/li&gt;
&lt;li&gt;ex: DI, encoders&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt; – позволяет объединить несколько reader от одного входного значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;State&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;передача дополнительного состояния в вычисления&lt;/li&gt;
&lt;li&gt;моделирование мутабельного состояния в pure functional подходе&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State[S, A]&lt;/code&gt; это &lt;code&gt;S =&amp;gt; (S, A)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (state, res) = a.run(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runS(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runA(v).value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;стандартные преобразования&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State.get&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.inspect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.modify&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;синтаксис&lt;ul&gt;
&lt;li&gt;for comprehension&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad transformers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;позволяют комбинировать монады&lt;/li&gt;
&lt;li&gt;комбинация невозможна без знаний об одной из двух монад&lt;/li&gt;
&lt;li&gt;например, EitherT позволяет комбинировать любую монаду с Either&lt;/li&gt;
&lt;li&gt;из коробки: &lt;code&gt;cats.data.{OptionT, EitherT, ReaderT, WriterT, StateT, IdT}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;соглашение: трансформер определяет внутреннюю монаду, а первый его тип - внешнюю. например, &lt;code&gt;OptionT[List, A]&lt;/code&gt; – создаст монаду для &lt;code&gt;List[Option[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;если нужно часто определять alias для типов в стеках монад, поможет scala compiler plugin king projector. с ним можно писать так: &lt;code&gt;123.pure[EitherT[Option, String, ?]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;использование для реализации:&lt;ul&gt;
&lt;li&gt;многие монады реализованы через трансформеры&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type ReaderT[F[_], A, B] = Kleisli[F, A, B]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type Writer[W, A] = WriterT[Id, W, A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Kleisli&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение функций &lt;code&gt;A =&amp;gt; F[B]&lt;/code&gt;, &lt;code&gt;B =&amp;gt; F[C]&lt;/code&gt; в &lt;code&gt;A =&amp;gt; F[C]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroupal&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединяет два контекста&lt;/li&gt;
&lt;li&gt;в литературе иногда называют Monoidal&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.map2&lt;/code&gt; ... &lt;code&gt;.map22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tuple2&lt;/code&gt; ... &lt;code&gt;.tuple22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.contramap2&lt;/code&gt; ... &lt;code&gt;.contramap22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.imap2&lt;/code&gt; ... &lt;code&gt;.imap22&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(a, b, c, ...).tupled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a, b, c ...).mapN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(Monoid[A], Monoid[B], ...).imapN(toF)(fromF)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Intellij Idea не понимает тип выражения после mapN, это &lt;a href="https://youtrack.jetbrains.com/issue/SCL-12892"&gt;недавно поправили&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Иногда получаемый результат не сразу очевиден. Например Semigroupal от двух списков будет прямое произведение (каждый с каждым), а не zip списков.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Validated&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналог Either, но с накоплением всех ошибок&lt;/li&gt;
&lt;li&gt;требует Semigroup для типа ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Validated.valid[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.invalid[E, A](e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchOnly[Throwable](f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchNonFatal(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromTry(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromEither[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromOption[E, A](a, e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.toEither&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withEither(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withValidated(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.getOrElse(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.fold(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.valid[E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.invalid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure[Validated[F[E], A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.raiseError[Validated[F[E], A], E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tupled&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Apply&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Semigroupal + Functor&lt;/li&gt;
&lt;li&gt;альтернативный к Semigroupal способ закодировать объединение контекстов&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ap(f)(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.product(a, b)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Applicative&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Apply + pure, который позволяет создать новый Applicative instance из сырого значения&lt;/li&gt;
&lt;li&gt;Monad = Applicative + FlatMap&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;NonEmpty*&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналоги стандартных коллекций, но имеющие строго один или более элементов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyList&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyVector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Foldable&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция для foldLeft / foldRight&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.foldLeft(a, i)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldRight(a, i: Eval[B])(f): Eval[B]&lt;/code&gt; (stack safe)&lt;/li&gt;
&lt;li&gt;привычные методы коллекций, поверх foldLeft: &lt;code&gt;.find&lt;/code&gt;, &lt;code&gt;.exists&lt;/code&gt;, &lt;code&gt;.forall&lt;/code&gt;, &lt;code&gt;.toList&lt;/code&gt;, &lt;code&gt;.isEmpty&lt;/code&gt;, &lt;code&gt;.nonEmpty&lt;/code&gt; ...&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.combineAll(a)&lt;/code&gt; (aka &lt;code&gt;.fold&lt;/code&gt;, требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldMap(a)(f)&lt;/code&gt; (требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.compose(other)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;все операции доступны как синтаксис&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.foldLeft(i)(f)&lt;/code&gt; и т. д.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Traverse&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея набор из F[A], получить F от набора А&lt;/li&gt;
&lt;li&gt;например, &lt;code&gt;List[Future[A]]&lt;/code&gt; → &lt;code&gt;Future[List[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.traverse(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.sequence(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.traverse(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.sequence&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="cats"></category><category term="scala"></category></entry></feed>