<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>blog.maizy.ru</title><link href="https://blog.maizy.ru/" rel="alternate"></link><link href="https://blog.maizy.ru/feeds/all-ru.atom.xml" rel="self"></link><id>https://blog.maizy.ru/</id><updated>2018-12-21T00:00:00+03:00</updated><entry><title>Конспект по Scala with Cats</title><link href="https://blog.maizy.ru/posts/scala-cats-summary" rel="alternate"></link><published>2018-12-21T00:00:00+03:00</published><updated>2018-12-21T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2018-12-21:/posts/scala-cats-summary</id><summary type="html">&lt;p&gt;Scala with Cats – это &lt;a href="https://underscore.io/books/scala-with-cats/"&gt;свободно доступная книга&lt;/a&gt;, написанная Noel Welsh и Dave Gurnell из Underscore. Охватывает все основы использования библиотеки &lt;a href="https://typelevel.org/cats/"&gt;cats&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Книгу рекомендую читать с выполнением заданий, без этого лично мне полного понимания достичь не удалось.&lt;/p&gt;
&lt;p&gt;Ниже краткий насколько возможно конспект по Type Class'ам из книги.&lt;/p&gt;
&lt;h3&gt;Show&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;вывести на печать любой тип&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.show&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eq&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;типобезопасное сравнение&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a === b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a =!= b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monoid&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.combine(a1, a2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.empty[A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;законы:&lt;ul&gt;
&lt;li&gt;combine ассоциативный&lt;/li&gt;
&lt;li&gt;empty должен быть нейтральным элементом (identity element)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение двух значений&lt;/li&gt;
&lt;li&gt;только combine из Monoid&lt;/li&gt;
&lt;li&gt;там где требуется Semigroup, всегда можно использовать Monoid&lt;/li&gt;
&lt;li&gt;нужен так как не всегда существует нейтральный элемент, пример – NonEmptyList&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;a |+| b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Functor&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;что-то у чего есть &lt;code&gt;map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;не стоит думать об этом только, как о проходе по списку, это может быть и работа с внутренним состоянием "контейнера" (в контексте этого "контейнера"), без извлечения значения из "контейнера".&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.lift(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f.map(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Contravariant (Functor)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;из &lt;code&gt;F[B]&lt;/code&gt; имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt; получить &lt;code&gt;F[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.contramap(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Invariant&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt;, &lt;code&gt;B =&amp;gt; A&lt;/code&gt; и &lt;code&gt;Monoid[B]&lt;/code&gt; получить &lt;code&gt;Monoid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;Monoid[B].imap(f)(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1000 разных подходов к определению, в книге такое: монада – механизм для последовательных вычислений&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt; – создание монадического контекста из сырого значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; – извлечение значения из контекста и создание следующего контекста в последовательности&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;любая монада – функтор, map легко построить из pure+flatMap&lt;/li&gt;
&lt;li&gt;laws:&lt;ul&gt;
&lt;li&gt;левоассоциативность: &lt;code&gt;pure(a).flatMap(f) == f(a)&lt;/code&gt;. тут важно помнить об эффектах. именно по этой причине Try не Monad, так как если "снять" с него контекст монады при обычном вызове получим эффект – исключение, а если не снять то получим Failure.&lt;/li&gt;
&lt;li&gt;правоассоциативность: &lt;code&gt;m.flatMap(pure) == m&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;ассоциативность: &lt;code&gt;m.flatMap(f).flatMap(g) == m.flatMap(x =&amp;gt; f(x).flatMap(g))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure[T]&lt;/code&gt; (из cats.syntax.applicative)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt; (из cats.syntax.functor)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; (из cats.syntax.flatMap)&lt;/li&gt;
&lt;li&gt;можно использовать for comprehensions из scala&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;при определении своих монад&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tailRecM&lt;/code&gt; – оптимизация для вложенных .flatMap вызовов. метод можно делать &lt;code&gt;@tailrec&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Id&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Identity Monad&lt;/li&gt;
&lt;li&gt;позволяет использовать в коде, где ожидаются монады немонадные значения&lt;/li&gt;
&lt;li&gt;мощный инструмент для тестов кода построенного на монадах&lt;/li&gt;
&lt;li&gt;например&lt;ul&gt;
&lt;li&gt;&lt;code&gt;123 : Id[Int]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"abc" : Id[String]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Either&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;обычный тип из scala&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.orElse(Either)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recover(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recoverWith(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;right bias (flatMap/map/filter работающие на правой части Either, есть из коробки в scala 2.12+)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asRight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asLeft&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MonadError&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция поверх Either для работы с ошибками&lt;/li&gt;
&lt;li&gt;параметризирован типом монады и типом ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.raiseError(e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.handleError(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(a)(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eval&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция над выполнением&lt;/li&gt;
&lt;li&gt;в частности: позволяет делать стекобезопасные рекурсивные вычисления&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.now(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.later(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.always(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.memoize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.defer(=&amp;gt; Eval)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Writer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;сбор лога при вычислении&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (log, result) = writer.run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapWritten(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapBoth( (log, res) =&amp;gt; ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.reset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.pure[T]&lt;/code&gt; (требует Monoid[T] в implicit scope)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.tell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.writer(seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Reader&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;построение цепочки операций на основе входных параметров&lt;/li&gt;
&lt;li&gt;ex: DI, encoders&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt; – позволяет объединить несколько reader от одного входного значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;State&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;передача дополнительного состояния в вычисления&lt;/li&gt;
&lt;li&gt;моделирование мутабельного состояния в pure functional подходе&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State[S, A]&lt;/code&gt; это &lt;code&gt;S =&amp;gt; (S, A)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (state, res) = a.run(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runS(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runA(v).value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;стандартные преобразования&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State.get&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.inspect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.modify&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;синтаксис&lt;ul&gt;
&lt;li&gt;for comprehension&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad transformers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;позволяют комбинировать монады&lt;/li&gt;
&lt;li&gt;комбинация невозможна без знаний об одной из двух монад&lt;/li&gt;
&lt;li&gt;например, EitherT позволяет комбинировать любую монаду с Either&lt;/li&gt;
&lt;li&gt;из коробки: &lt;code&gt;cats.data.{OptionT, EitherT, ReaderT, WriterT, StateT, IdT}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;соглашение: трансформер определяет внутреннюю монаду, а первый его тип - внешнюю. например, &lt;code&gt;OptionT[List, A]&lt;/code&gt; – создаст монаду для &lt;code&gt;List[Option[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;если нужно часто определять alias для типов в стеках монад, поможет scala compiler plugin king projector. с ним можно писать так: &lt;code&gt;123.pure[EitherT[Option, String, ?]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;использование для реализации:&lt;ul&gt;
&lt;li&gt;многие монады реализованы через трансформеры&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type ReaderT[F[_], A, B] = Kleisli[F, A, B]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type Writer[W, A] = WriterT[Id, W, A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Kleisli&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение функций &lt;code&gt;A =&amp;gt; F[B]&lt;/code&gt;, &lt;code&gt;B =&amp;gt; F[C]&lt;/code&gt; в &lt;code&gt;A =&amp;gt; F[C]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroupal&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединяет два контекста&lt;/li&gt;
&lt;li&gt;в литературе иногда называют Monoidal&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.map2&lt;/code&gt; ... &lt;code&gt;.map22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tuple2&lt;/code&gt; ... &lt;code&gt;.tuple22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.contramap2&lt;/code&gt; ... &lt;code&gt;.contramap22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.imap2&lt;/code&gt; ... &lt;code&gt;.imap22&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(a, b, c, ...).tupled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a, b, c ...).mapN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(Monoid[A], Monoid[B], ...).imapN(toF)(fromF)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Intellij Idea не понимает тип выражения после mapN, это &lt;a href="https://youtrack.jetbrains.com/issue/SCL-12892"&gt;недавно поправили&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Иногда получаемый результат не сразу очевиден. Например Semigroupal от двух списков будет прямое произведение (каждый с каждым), а не zip списков.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Validated&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналог Either, но с накоплением всех ошибок&lt;/li&gt;
&lt;li&gt;требует Semigroup для типа ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Validated.valid[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.invalid[E, A](e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchOnly[Throwable](f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchNonFatal(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromTry(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromEither[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromOption[E, A](a, e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.toEither&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withEither(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withValidated(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.getOrElse(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.fold(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.valid[E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.invalid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure[Validated[F[E], A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.raiseError[Validated[F[E], A], E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tupled&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Apply&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Semigroupal + Functor&lt;/li&gt;
&lt;li&gt;альтернативный к Semigroupal способ закодировать объединение контекстов&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ap(f)(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.product(a, b)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Applicative&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Apply + pure, который позволяет создать новый Applicative instance из сырого значения&lt;/li&gt;
&lt;li&gt;Monad = Applicative + FlatMap&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;NonEmpty*&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналоги стандартных коллекций, но имеющие строго один или более элементов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyList&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyVector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Foldable&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция для foldLeft / foldRight&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.foldLeft(a, i)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldRight(a, i: Eval[B])(f): Eval[B]&lt;/code&gt; (stack safe)&lt;/li&gt;
&lt;li&gt;привычные методы коллекций, поверх foldLeft: &lt;code&gt;.find&lt;/code&gt;, &lt;code&gt;.exists&lt;/code&gt;, &lt;code&gt;.forall&lt;/code&gt;, &lt;code&gt;.toList&lt;/code&gt;, &lt;code&gt;.isEmpty&lt;/code&gt;, &lt;code&gt;.nonEmpty&lt;/code&gt; ...&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.combineAll(a)&lt;/code&gt; (aka &lt;code&gt;.fold&lt;/code&gt;, требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldMap(a)(f)&lt;/code&gt; (требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.compose(other)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;все операции доступны как синтаксис&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.foldLeft(i)(f)&lt;/code&gt; и т. д.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Traverse&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея набор из F[A], получить F от набора А&lt;/li&gt;
&lt;li&gt;например, &lt;code&gt;List[Future[A]]&lt;/code&gt; → &lt;code&gt;Future[List[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.traverse(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.sequence(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.traverse(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.sequence&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Scala with Cats – это &lt;a href="https://underscore.io/books/scala-with-cats/"&gt;свободно доступная книга&lt;/a&gt;, написанная Noel Welsh и Dave Gurnell из Underscore. Охватывает все основы использования библиотеки &lt;a href="https://typelevel.org/cats/"&gt;cats&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Книгу рекомендую читать с выполнением заданий, без этого лично мне полного понимания достичь не удалось.&lt;/p&gt;
&lt;p&gt;Ниже краткий насколько возможно конспект по Type Class'ам из книги.&lt;/p&gt;
&lt;h3&gt;Show&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;вывести на печать любой тип&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.show&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eq&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;типобезопасное сравнение&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a === b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a =!= b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monoid&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.combine(a1, a2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.empty[A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;законы:&lt;ul&gt;
&lt;li&gt;combine ассоциативный&lt;/li&gt;
&lt;li&gt;empty должен быть нейтральным элементом (identity element)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroup&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение двух значений&lt;/li&gt;
&lt;li&gt;только combine из Monoid&lt;/li&gt;
&lt;li&gt;там где требуется Semigroup, всегда можно использовать Monoid&lt;/li&gt;
&lt;li&gt;нужен так как не всегда существует нейтральный элемент, пример – NonEmptyList&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;a |+| b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Functor&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;что-то у чего есть &lt;code&gt;map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;не стоит думать об этом только, как о проходе по списку, это может быть и работа с внутренним состоянием "контейнера" (в контексте этого "контейнера"), без извлечения значения из "контейнера".&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.lift(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f.map(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Contravariant (Functor)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;из &lt;code&gt;F[B]&lt;/code&gt; имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt; получить &lt;code&gt;F[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;.contramap(f)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Invariant&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея &lt;code&gt;A =&amp;gt; B&lt;/code&gt;, &lt;code&gt;B =&amp;gt; A&lt;/code&gt; и &lt;code&gt;Monoid[B]&lt;/code&gt; получить &lt;code&gt;Monoid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax: &lt;code&gt;Monoid[B].imap(f)(g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1000 разных подходов к определению, в книге такое: монада – механизм для последовательных вычислений&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt; – создание монадического контекста из сырого значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; – извлечение значения из контекста и создание следующего контекста в последовательности&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;любая монада – функтор, map легко построить из pure+flatMap&lt;/li&gt;
&lt;li&gt;laws:&lt;ul&gt;
&lt;li&gt;левоассоциативность: &lt;code&gt;pure(a).flatMap(f) == f(a)&lt;/code&gt;. тут важно помнить об эффектах. именно по этой причине Try не Monad, так как если "снять" с него контекст монады при обычном вызове получим эффект – исключение, а если не снять то получим Failure.&lt;/li&gt;
&lt;li&gt;правоассоциативность: &lt;code&gt;m.flatMap(pure) == m&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;ассоциативность: &lt;code&gt;m.flatMap(f).flatMap(g) == m.flatMap(x =&amp;gt; f(x).flatMap(g))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure[T]&lt;/code&gt; (из cats.syntax.applicative)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt; (из cats.syntax.functor)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.flatMap(f)&lt;/code&gt; (из cats.syntax.flatMap)&lt;/li&gt;
&lt;li&gt;можно использовать for comprehensions из scala&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;при определении своих монад&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tailRecM&lt;/code&gt; – оптимизация для вложенных .flatMap вызовов. метод можно делать &lt;code&gt;@tailrec&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Id&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Identity Monad&lt;/li&gt;
&lt;li&gt;позволяет использовать в коде, где ожидаются монады немонадные значения&lt;/li&gt;
&lt;li&gt;мощный инструмент для тестов кода построенного на монадах&lt;/li&gt;
&lt;li&gt;например&lt;ul&gt;
&lt;li&gt;&lt;code&gt;123 : Id[Int]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;"abc" : Id[String]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Either&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;обычный тип из scala&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.orElse(Either)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recover(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.recoverWith(partialFunction)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;right bias (flatMap/map/filter работающие на правой части Either, есть из коробки в scala 2.12+)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asRight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.asLeft&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MonadError&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция поверх Either для работы с ошибками&lt;/li&gt;
&lt;li&gt;параметризирован типом монады и типом ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.raiseError(e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.handleError(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.ensure(a)(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ensure(e)(predicate)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Eval&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция над выполнением&lt;/li&gt;
&lt;li&gt;в частности: позволяет делать стекобезопасные рекурсивные вычисления&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.now(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.later(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.always(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.memoize&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.defer(=&amp;gt; Eval)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Writer&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;сбор лога при вычислении&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (log, result) = writer.run&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapWritten(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.mapBoth( (log, res) =&amp;gt; ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.reset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.swap&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.pure[T]&lt;/code&gt; (требует Monoid[T] в implicit scope)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.tell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.writer(seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Reader&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;построение цепочки операций на основе входных параметров&lt;/li&gt;
&lt;li&gt;ex: DI, encoders&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.flatMap&lt;/code&gt; – позволяет объединить несколько reader от одного входного значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;State&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;передача дополнительного состояния в вычисления&lt;/li&gt;
&lt;li&gt;моделирование мутабельного состояния в pure functional подходе&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State[S, A]&lt;/code&gt; это &lt;code&gt;S =&amp;gt; (S, A)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;val (state, res) = a.run(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runS(v).value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.runA(v).value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;стандартные преобразования&lt;ul&gt;
&lt;li&gt;&lt;code&gt;State.get&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.inspect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;State.modify&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;синтаксис&lt;ul&gt;
&lt;li&gt;for comprehension&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Monad transformers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;позволяют комбинировать монады&lt;/li&gt;
&lt;li&gt;комбинация невозможна без знаний об одной из двух монад&lt;/li&gt;
&lt;li&gt;например, EitherT позволяет комбинировать любую монаду с Either&lt;/li&gt;
&lt;li&gt;из коробки: &lt;code&gt;cats.data.{OptionT, EitherT, ReaderT, WriterT, StateT, IdT}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;соглашение: трансформер определяет внутреннюю монаду, а первый его тип - внешнюю. например, &lt;code&gt;OptionT[List, A]&lt;/code&gt; – создаст монаду для &lt;code&gt;List[Option[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;если нужно часто определять alias для типов в стеках монад, поможет scala compiler plugin king projector. с ним можно писать так: &lt;code&gt;123.pure[EitherT[Option, String, ?]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;использование для реализации:&lt;ul&gt;
&lt;li&gt;многие монады реализованы через трансформеры&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type ReaderT[F[_], A, B] = Kleisli[F, A, B]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type Writer[W, A] = WriterT[Id, W, A]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Kleisli&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединение функций &lt;code&gt;A =&amp;gt; F[B]&lt;/code&gt;, &lt;code&gt;B =&amp;gt; F[C]&lt;/code&gt; в &lt;code&gt;A =&amp;gt; F[C]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Semigroupal&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;объединяет два контекста&lt;/li&gt;
&lt;li&gt;в литературе иногда называют Monoidal&lt;/li&gt;
&lt;li&gt;операции:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.map2&lt;/code&gt; ... &lt;code&gt;.map22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tuple2&lt;/code&gt; ... &lt;code&gt;.tuple22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.contramap2&lt;/code&gt; ... &lt;code&gt;.contramap22&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.imap2&lt;/code&gt; ... &lt;code&gt;.imap22&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(a, b, c, ...).tupled&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(a, b, c ...).mapN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(Monoid[A], Monoid[B], ...).imapN(toF)(fromF)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Intellij Idea не понимает тип выражения после mapN, это &lt;a href="https://youtrack.jetbrains.com/issue/SCL-12892"&gt;недавно поправили&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Иногда получаемый результат не сразу очевиден. Например Semigroupal от двух списков будет прямое произведение (каждый с каждым), а не zip списков.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Validated&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналог Either, но с накоплением всех ошибок&lt;/li&gt;
&lt;li&gt;требует Semigroup для типа ошибки&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Validated.valid[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.invalid[E, A](e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchOnly[Throwable](f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.catchNonFatal(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromTry(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromEither[E, A](a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validated.fromOption[E, A](a, e)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.map(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.leftMap(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bimap(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.toEither&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withEither(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.withValidated(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.getOrElse(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.fold(f, g)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.valid[E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.invalid[A]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.pure[Validated[F[E], A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.raiseError[Validated[F[E], A], E]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.tupled&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Apply&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Semigroupal + Functor&lt;/li&gt;
&lt;li&gt;альтернативный к Semigroupal способ закодировать объединение контекстов&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.ap(f)(a)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.product(a, b)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Applicative&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Apply + pure, который позволяет создать новый Applicative instance из сырого значения&lt;/li&gt;
&lt;li&gt;Monad = Applicative + FlatMap&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.pure(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;NonEmpty*&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;аналоги стандартных коллекций, но имеющие строго один или более элементов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyList&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NonEmptyVector&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Foldable&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;абстракция для foldLeft / foldRight&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.foldLeft(a, i)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldRight(a, i: Eval[B])(f): Eval[B]&lt;/code&gt; (stack safe)&lt;/li&gt;
&lt;li&gt;привычные методы коллекций, поверх foldLeft: &lt;code&gt;.find&lt;/code&gt;, &lt;code&gt;.exists&lt;/code&gt;, &lt;code&gt;.forall&lt;/code&gt;, &lt;code&gt;.toList&lt;/code&gt;, &lt;code&gt;.isEmpty&lt;/code&gt;, &lt;code&gt;.nonEmpty&lt;/code&gt; ...&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.combineAll(a)&lt;/code&gt; (aka &lt;code&gt;.fold&lt;/code&gt;, требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.foldMap(a)(f)&lt;/code&gt; (требует Monoid)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.compose(other)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;все операции доступны как синтаксис&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.foldLeft(i)(f)&lt;/code&gt; и т. д.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Traverse&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;имея набор из F[A], получить F от набора А&lt;/li&gt;
&lt;li&gt;например, &lt;code&gt;List[Future[A]]&lt;/code&gt; → &lt;code&gt;Future[List[A]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;операции&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.traverse(a)(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.sequence(a)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;syntax:&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a.traverse(f)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a.sequence&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="cats"></category><category term="scala"></category></entry><entry><title>Обзоры видео на технические темы, январь-сентябрь 2016</title><link href="https://blog.maizy.ru/posts/video-jan-oct-2016" rel="alternate"></link><published>2016-10-05T00:00:00+03:00</published><updated>2016-10-05T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2016-10-05:/posts/video-jan-oct-2016</id><summary type="html">&lt;p&gt;Каждый рабочий день, в обеденный перерыв, у меня есть 15-20 минут на просмотр видео. Читать в этот момент не удобно, это отвлекает от процедуры поглощения пищи, а видео в самый раз.&lt;/p&gt;
&lt;p&gt;Впечатления от видео за январь-октябрь этого года в этом посте. В последующем планирую переодически делать такие обзоры.&lt;/p&gt;
&lt;p&gt;Предыдущий похожий обзор – &lt;a href="https://blog.maizy.ru/posts/scala-days-2015-sf"&gt;Видео со ScalaDays 2015 San Francisco&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=Mw_Jnn_Y5iA"&gt;Scala Monads: Declutter Your Code With Monadic Design – Dan Rosen&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;общие слова про монады, flatmap и map&lt;/li&gt;
&lt;li&gt;примеры на scalaz&lt;/li&gt;
&lt;li&gt;Хороший вывод в конце - монады что-то прячут, заменяя это на типы. Option прячет boilerplate от "if non-null" logic, Validation – try/catch и т.д.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=uKc0Gx_lPsg"&gt;The Multi-threading, Non Blocking IO – Heinz Kabutz&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Live coding сессия. Объясняется способ написать сервер: блокирующий, неблокирующий на nio, с тредами или с селекторами. Интересно.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=uZd-MvN1n4E"&gt;Scalaz: the history, the motivation, the battles, the future – Tony Morris&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Не интересно.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=Cc2QtbjUX60"&gt;Фреймворк Akka и его использование в Яндексе – Вадим Цесько&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Интересно не сколько про саму akka, там уже некоторые вещи неактуальны для новых версий. Для себя вынес только факт того, что не стоит крутить акторы в системном дефолтном диспечере.&lt;/li&gt;
&lt;li&gt;Интересно было послушать про систему в общем и узнать, как построена структура обработки данных.&lt;/li&gt;
&lt;li&gt;Интересно смотреть, как это всё меняется, и меняется ли в связи с akka streams.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=9xFfOhasiOE"&gt;CRDTs Illustrated – Arnout Engelen&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хороший начальный обзор CRDT с наглядными схемами.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=IOiZatlZtGU"&gt;Propositions as Types – Philip Wadler&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Известный доклад Вадлера. Стоит посмотреть и посмотреть до конца.&lt;/li&gt;
&lt;li&gt;Вадлер рассказывает об истории развития теоретической базы под разными концепциями, на которых построены языки программирования.&lt;/li&gt;
&lt;li&gt;Выжимка: все изобретено дважды. Сначала математиками, потом в computer science.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=jyMIvcUxOJ0"&gt;Learning scalaz – Eugene Yokota&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Очень поверхностный рассказ про scalaz, скорее про проблемы, которые он может решить.&lt;/li&gt;
&lt;li&gt;В конце – список полезных книг и их обзор.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://engineering.twitter.com/university/videos/zipkin-at-twitter"&gt;Zipkin at Twitter – Jeff Smick&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Zipkin – система трассировки логов в распределённых сервисах.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Подход интересный, в других системах я такого не видел.&lt;/li&gt;
&lt;li&gt;Сложилось впечатление, что использовать за пределами твиттер-стека не удобно.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://skillsmatter.com/skillscasts/6483-keynote-scaling-intelligence-moving-ideas-forward"&gt;Scaling Intelligence: moving ideas forward – Jessica Kerr&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Про кривую изучения scala и community вокруг языка. Про то, как должна выглядеть документация и руководства, чтобы они были понятны людям с разными уровнями понимания computer science и математики, присутствующей в scala.&lt;/p&gt;
&lt;p&gt;Позиция автора очень релевантна моему представлению о процессе обучения.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://skillsmatter.com/skillscasts/6939-optimising-scala-for-fun-and-profit"&gt;Optimising Scala for fun and profit – Rory Graves&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Несколько простых и понятных способов понять, что сделать, чтобы scala работала быстрее. Также про магию, которая лежит за красивыми концепциями в scala, и чего это стоит для производительности.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Каждый рабочий день, в обеденный перерыв, у меня есть 15-20 минут на просмотр видео. Читать в этот момент не удобно, это отвлекает от процедуры поглощения пищи, а видео в самый раз.&lt;/p&gt;
&lt;p&gt;Впечатления от видео за январь-октябрь этого года в этом посте. В последующем планирую переодически делать такие обзоры.&lt;/p&gt;
&lt;p&gt;Предыдущий похожий обзор – &lt;a href="https://blog.maizy.ru/posts/scala-days-2015-sf"&gt;Видео со ScalaDays 2015 San Francisco&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=Mw_Jnn_Y5iA"&gt;Scala Monads: Declutter Your Code With Monadic Design – Dan Rosen&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;общие слова про монады, flatmap и map&lt;/li&gt;
&lt;li&gt;примеры на scalaz&lt;/li&gt;
&lt;li&gt;Хороший вывод в конце - монады что-то прячут, заменяя это на типы. Option прячет boilerplate от "if non-null" logic, Validation – try/catch и т.д.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=uKc0Gx_lPsg"&gt;The Multi-threading, Non Blocking IO – Heinz Kabutz&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Live coding сессия. Объясняется способ написать сервер: блокирующий, неблокирующий на nio, с тредами или с селекторами. Интересно.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=uZd-MvN1n4E"&gt;Scalaz: the history, the motivation, the battles, the future – Tony Morris&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Не интересно.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=Cc2QtbjUX60"&gt;Фреймворк Akka и его использование в Яндексе – Вадим Цесько&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Интересно не сколько про саму akka, там уже некоторые вещи неактуальны для новых версий. Для себя вынес только факт того, что не стоит крутить акторы в системном дефолтном диспечере.&lt;/li&gt;
&lt;li&gt;Интересно было послушать про систему в общем и узнать, как построена структура обработки данных.&lt;/li&gt;
&lt;li&gt;Интересно смотреть, как это всё меняется, и меняется ли в связи с akka streams.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=9xFfOhasiOE"&gt;CRDTs Illustrated – Arnout Engelen&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хороший начальный обзор CRDT с наглядными схемами.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.youtube.com/watch?v=IOiZatlZtGU"&gt;Propositions as Types – Philip Wadler&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Известный доклад Вадлера. Стоит посмотреть и посмотреть до конца.&lt;/li&gt;
&lt;li&gt;Вадлер рассказывает об истории развития теоретической базы под разными концепциями, на которых построены языки программирования.&lt;/li&gt;
&lt;li&gt;Выжимка: все изобретено дважды. Сначала математиками, потом в computer science.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=jyMIvcUxOJ0"&gt;Learning scalaz – Eugene Yokota&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Очень поверхностный рассказ про scalaz, скорее про проблемы, которые он может решить.&lt;/li&gt;
&lt;li&gt;В конце – список полезных книг и их обзор.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://engineering.twitter.com/university/videos/zipkin-at-twitter"&gt;Zipkin at Twitter – Jeff Smick&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Zipkin – система трассировки логов в распределённых сервисах.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Подход интересный, в других системах я такого не видел.&lt;/li&gt;
&lt;li&gt;Сложилось впечатление, что использовать за пределами твиттер-стека не удобно.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href="https://skillsmatter.com/skillscasts/6483-keynote-scaling-intelligence-moving-ideas-forward"&gt;Scaling Intelligence: moving ideas forward – Jessica Kerr&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Про кривую изучения scala и community вокруг языка. Про то, как должна выглядеть документация и руководства, чтобы они были понятны людям с разными уровнями понимания computer science и математики, присутствующей в scala.&lt;/p&gt;
&lt;p&gt;Позиция автора очень релевантна моему представлению о процессе обучения.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://skillsmatter.com/skillscasts/6939-optimising-scala-for-fun-and-profit"&gt;Optimising Scala for fun and profit – Rory Graves&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Несколько простых и понятных способов понять, что сделать, чтобы scala работала быстрее. Также про магию, которая лежит за красивыми концепциями в scala, и чего это стоит для производительности.&lt;/p&gt;</content><category term="video"></category><category term="scala"></category></entry><entry><title>Видео со ScalaDays 2015 San Francisco</title><link href="https://blog.maizy.ru/posts/scala-days-2015-sf" rel="alternate"></link><published>2015-12-09T00:00:00+03:00</published><updated>2015-12-09T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-12-09:/posts/scala-days-2015-sf</id><summary type="html">&lt;p&gt;Заметки к некоторым видео с главной scala конференции. Все видео и слайды давно доступны на сайте &lt;a href="https://www.parleys.com/channel/scala-days-san-francisco-2015"&gt;parleys.com&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/scala-where-came-from-where-its-going"&gt;Scala - where it came from, where it's going - Martin Odersky&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Key note конференции. Советую всем, кто интересуется будущим scala и взглядом на это Мартина. Упоминали новый компилятор dotty, scala.js, scala 2.12. Кстати да, DSL для XML собираются вынести из языка в строковые интерполяторы.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/akka-http-reactive-web-toolkit"&gt;Akka HTTP: the Reactive Web Toolkit - Roland Kuhn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Про стримы в Akka, с демонстрациями кода. Роланд начинает с соединения TCP со стримами, описывает реализации кастомных протоколов и доходит к тому, как на всём этом реализован HTTP. В ответах на вопросы к докладу упомянуто много планов по развитию стримов и HTTP в akka. Из важного я узнал, что netty внутри play планируют заменить на новый HTTP core.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/reactive-slick-database-programming"&gt;Reactive Slick for Database Programming - Stefan Zeiger&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;В начале доклада капитанские вещи о том, какие проблемы есть с БД в асинхронных окружениях и как их принято решать. Затем описывается state и IO монады. Затем объяснятся как slick решает вопросы доступа к БД, представления результатов и зачем там Futures. Интересную мысль, которую я вынес, что при текущей моделе БД асинхронные драйвера, которые стали появляться, не решают проблему, так как внизу БД всё равно работает в синхронном стиле.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/type-level-programming-scala-101"&gt;Type-level Programming in Scala 101 - Joe Barnes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Весёлая вводная в type-level программирование без углубления в незначительные на первых этапах детали. С примерами кода и тестов. Доклад в режиме ответов на вопросы, которые, к сожалению, не всегда слышно.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/function-passing-style-new-model-asynchronous-distributed-programming"&gt;Function-Passing Style, A New Model for Asynchronous and Distributed Programming - Heather Miller&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Интересный доклад о попытках написать решение, которое в некоторых случаях может использоваться как замена модели акторов. В двух словах идея в том, что стейт может жить в одном месте, а обработка его вызываться из другого, для чего по сети можно передавать лямбды, вместо данных. При этом топология решения может быть любая, как ptp, так и master-slave, например. Если я всё правильно уловил, уже есть работающий прототип.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Заметки к некоторым видео с главной scala конференции. Все видео и слайды давно доступны на сайте &lt;a href="https://www.parleys.com/channel/scala-days-san-francisco-2015"&gt;parleys.com&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/scala-where-came-from-where-its-going"&gt;Scala - where it came from, where it's going - Martin Odersky&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Key note конференции. Советую всем, кто интересуется будущим scala и взглядом на это Мартина. Упоминали новый компилятор dotty, scala.js, scala 2.12. Кстати да, DSL для XML собираются вынести из языка в строковые интерполяторы.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/akka-http-reactive-web-toolkit"&gt;Akka HTTP: the Reactive Web Toolkit - Roland Kuhn&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Про стримы в Akka, с демонстрациями кода. Роланд начинает с соединения TCP со стримами, описывает реализации кастомных протоколов и доходит к тому, как на всём этом реализован HTTP. В ответах на вопросы к докладу упомянуто много планов по развитию стримов и HTTP в akka. Из важного я узнал, что netty внутри play планируют заменить на новый HTTP core.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/reactive-slick-database-programming"&gt;Reactive Slick for Database Programming - Stefan Zeiger&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;В начале доклада капитанские вещи о том, какие проблемы есть с БД в асинхронных окружениях и как их принято решать. Затем описывается state и IO монады. Затем объяснятся как slick решает вопросы доступа к БД, представления результатов и зачем там Futures. Интересную мысль, которую я вынес, что при текущей моделе БД асинхронные драйвера, которые стали появляться, не решают проблему, так как внизу БД всё равно работает в синхронном стиле.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/type-level-programming-scala-101"&gt;Type-level Programming in Scala 101 - Joe Barnes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Весёлая вводная в type-level программирование без углубления в незначительные на первых этапах детали. С примерами кода и тестов. Доклад в режиме ответов на вопросы, которые, к сожалению, не всегда слышно.&lt;/p&gt;
&lt;h3&gt;&lt;a href="https://www.parleys.com/tutorial/function-passing-style-new-model-asynchronous-distributed-programming"&gt;Function-Passing Style, A New Model for Asynchronous and Distributed Programming - Heather Miller&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Интересный доклад о попытках написать решение, которое в некоторых случаях может использоваться как замена модели акторов. В двух словах идея в том, что стейт может жить в одном месте, а обработка его вызываться из другого, для чего по сети можно передавать лямбды, вместо данных. При этом топология решения может быть любая, как ptp, так и master-slave, например. Если я всё правильно уловил, уже есть работающий прототип.&lt;/p&gt;</content><category term="scala"></category><category term="conference"></category></entry><entry><title>Мониторинг CO2 и работа с USB на scala</title><link href="https://blog.maizy.ru/posts/mt8057-usb-hid-scala" rel="alternate"></link><published>2015-11-12T00:00:00+03:00</published><updated>2015-11-12T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-11-12:/posts/mt8057-usb-hid-scala</id><summary type="html">&lt;p&gt;Озадачился мониторингом CO2 в помещениях. Сначала смотрел на отдельные датчики, думая собрать на коленке и rPi, но потом нашёл дешёвый сборный комплект &lt;a href="http://masterkit.ru/shop/others/dadget/1266110"&gt;Masterkit MT8057&lt;/a&gt;. Он настолько отличный, что с удовольствием его рекламирую.&lt;/p&gt;
&lt;p&gt;В результате у меня &lt;a href="#res"&gt;получился драйвер к MT8057 на scala и stand alone утилита&lt;/a&gt;, ниже в посте поделюсь некоторыми заметками к этой реализации.&lt;/p&gt;
&lt;h3&gt;Драйвер MT8057&lt;/h3&gt;
&lt;p&gt;Для MT8057 есть opensource реализация утилиты для съёма параметров от Олега Булатова написанная на C – &lt;a href="https://github.com/dmage/co2mon"&gt;co2mon&lt;/a&gt;. co2mon вариант хороший и рабочий, поддерживает и OS X, и Linux. Наверное, я бы справился докрутить туда выгрузку данных в InfluxDB, куда я собирался сложить все метрики, но решил пописать своих велосипедов, попрактиковаться в низкоуровневых штуках на scala и вспомнить работу с USB.&lt;/p&gt;
&lt;p&gt;В первый подход взял хороший и зрелый проект &lt;a href="http://usb4java.org/"&gt;usb4java&lt;/a&gt;, но оказалось, что с поддержкой OS X там беда. Требуются извращения типа &lt;a href="https://github.com/libusb/libusb/wiki/FAQ#How_can_I_run_libusb_applications_under_Mac_OS_X_if_there_is_already_a_kernel_extension_installed_for_the_device"&gt;выгрузки-загрузки kext'ов&lt;/a&gt;, которые у меня ещё и не завелись с первого раза.&lt;/p&gt;
&lt;p&gt;Во второй подход взял &lt;a href="https://github.com/gary-rowe/hid4java"&gt;hid4java&lt;/a&gt;, этот продукт хоть и анонсируется, как годный к production использованию, ещё достаточно сырой. Шаг влево, шаг вправо и ловишь jvm crash где-то в кишках интеграции с C-шной библиотекой. Написан через &lt;a href="https://github.com/java-native-access/jna"&gt;JNA&lt;/a&gt;, внутри лежат скомпилированные библиотеки для Linux x86_64, Linux ARM, OS X и ещё нескольких платформ. На OS X работает без всяких танцев с kext'ами. Из проблем – API не очень удобный, хуки вызываются из каких попало тредов, у меня это обходится с помощью обёртки с потокобезопасной очередью. Часть методов работает как бы правильно, возвращает правильные Java объекты, но при попытке что-то вызвать у этого объекта получаешь ошибку или crash, так что пришлось &lt;a href="https://github.com/maizy/ambient7/blob/41e6b92a9ca21769d6e9c7c5a47868d1740f8b5a/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MT8057Service.scala#L99-L101"&gt;добавить костыль&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;HID это отдельный класс USB устройств, поэтому не всегда будет выбор между этими библиотеками, в частности usb4java (а вернее libusb) ничего про HID &lt;a href="http://www.libusb.org/wiki/APIs#libusb-1.0currentAPIandimplementation"&gt;не знает и знать не собирается&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Scala для работы с байтами&lt;/h3&gt;
&lt;p&gt;В scala всё просто и удобно. Массивы java типа &lt;code&gt;byte[]&lt;/code&gt; в Scala превращаются в &lt;code&gt;Array[Byte]&lt;/code&gt;. Вооружившись в добавок &lt;code&gt;scala.collection.JavaConversions&lt;/code&gt; можно писать привычный scala код.&lt;/p&gt;
&lt;p&gt;Внутри драйвера есть &lt;a href="https://github.com/maizy/ambient7/blob/master/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MessageDecoder.scala"&gt;зубодробительный код с распаковкой данных&lt;/a&gt; от MT8057 и всё это неплохо легло в scala код, местами даже функциональный.&lt;/p&gt;
&lt;p&gt;&lt;a name="res"/&gt;&lt;/p&gt;
&lt;h3&gt;Результат&lt;/h3&gt;
&lt;p&gt;На выходе у меня получился драйвер MT8057 и декодер к HID пакетам с данными. В отдельный артефакт я их не выделял, но при необходимости это можно сделать.&lt;/p&gt;
&lt;p&gt;Про драйвер можно ничего не знать и использовать готовую утилиту &lt;a href="https://github.com/maizy/ambient7#mt8057-agent"&gt;ambient7-mt8057-agent&lt;/a&gt; которая из зависимостей требует только jre 1.6+ и пока умеет выводить данные в stdout/stderr (для записи в текстовый лог) или работать в интерактивном режиме с ANSI цветами в консоле. На подходе ещё возможность писать в InfluxDB. Готовый jar можно &lt;a href="https://github.com/maizy/ambient7#download"&gt;скачать в github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Про InfluxDB, если удастся с ним подружиться, расскажу отдельно.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Озадачился мониторингом CO2 в помещениях. Сначала смотрел на отдельные датчики, думая собрать на коленке и rPi, но потом нашёл дешёвый сборный комплект &lt;a href="http://masterkit.ru/shop/others/dadget/1266110"&gt;Masterkit MT8057&lt;/a&gt;. Он настолько отличный, что с удовольствием его рекламирую.&lt;/p&gt;
&lt;p&gt;В результате у меня &lt;a href="#res"&gt;получился драйвер к MT8057 на scala и stand alone утилита&lt;/a&gt;, ниже в посте поделюсь некоторыми заметками к этой реализации.&lt;/p&gt;
&lt;h3&gt;Драйвер MT8057&lt;/h3&gt;
&lt;p&gt;Для MT8057 есть opensource реализация утилиты для съёма параметров от Олега Булатова написанная на C – &lt;a href="https://github.com/dmage/co2mon"&gt;co2mon&lt;/a&gt;. co2mon вариант хороший и рабочий, поддерживает и OS X, и Linux. Наверное, я бы справился докрутить туда выгрузку данных в InfluxDB, куда я собирался сложить все метрики, но решил пописать своих велосипедов, попрактиковаться в низкоуровневых штуках на scala и вспомнить работу с USB.&lt;/p&gt;
&lt;p&gt;В первый подход взял хороший и зрелый проект &lt;a href="http://usb4java.org/"&gt;usb4java&lt;/a&gt;, но оказалось, что с поддержкой OS X там беда. Требуются извращения типа &lt;a href="https://github.com/libusb/libusb/wiki/FAQ#How_can_I_run_libusb_applications_under_Mac_OS_X_if_there_is_already_a_kernel_extension_installed_for_the_device"&gt;выгрузки-загрузки kext'ов&lt;/a&gt;, которые у меня ещё и не завелись с первого раза.&lt;/p&gt;
&lt;p&gt;Во второй подход взял &lt;a href="https://github.com/gary-rowe/hid4java"&gt;hid4java&lt;/a&gt;, этот продукт хоть и анонсируется, как годный к production использованию, ещё достаточно сырой. Шаг влево, шаг вправо и ловишь jvm crash где-то в кишках интеграции с C-шной библиотекой. Написан через &lt;a href="https://github.com/java-native-access/jna"&gt;JNA&lt;/a&gt;, внутри лежат скомпилированные библиотеки для Linux x86_64, Linux ARM, OS X и ещё нескольких платформ. На OS X работает без всяких танцев с kext'ами. Из проблем – API не очень удобный, хуки вызываются из каких попало тредов, у меня это обходится с помощью обёртки с потокобезопасной очередью. Часть методов работает как бы правильно, возвращает правильные Java объекты, но при попытке что-то вызвать у этого объекта получаешь ошибку или crash, так что пришлось &lt;a href="https://github.com/maizy/ambient7/blob/41e6b92a9ca21769d6e9c7c5a47868d1740f8b5a/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MT8057Service.scala#L99-L101"&gt;добавить костыль&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;HID это отдельный класс USB устройств, поэтому не всегда будет выбор между этими библиотеками, в частности usb4java (а вернее libusb) ничего про HID &lt;a href="http://www.libusb.org/wiki/APIs#libusb-1.0currentAPIandimplementation"&gt;не знает и знать не собирается&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Scala для работы с байтами&lt;/h3&gt;
&lt;p&gt;В scala всё просто и удобно. Массивы java типа &lt;code&gt;byte[]&lt;/code&gt; в Scala превращаются в &lt;code&gt;Array[Byte]&lt;/code&gt;. Вооружившись в добавок &lt;code&gt;scala.collection.JavaConversions&lt;/code&gt; можно писать привычный scala код.&lt;/p&gt;
&lt;p&gt;Внутри драйвера есть &lt;a href="https://github.com/maizy/ambient7/blob/master/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MessageDecoder.scala"&gt;зубодробительный код с распаковкой данных&lt;/a&gt; от MT8057 и всё это неплохо легло в scala код, местами даже функциональный.&lt;/p&gt;
&lt;p&gt;&lt;a name="res"/&gt;&lt;/p&gt;
&lt;h3&gt;Результат&lt;/h3&gt;
&lt;p&gt;На выходе у меня получился драйвер MT8057 и декодер к HID пакетам с данными. В отдельный артефакт я их не выделял, но при необходимости это можно сделать.&lt;/p&gt;
&lt;p&gt;Про драйвер можно ничего не знать и использовать готовую утилиту &lt;a href="https://github.com/maizy/ambient7#mt8057-agent"&gt;ambient7-mt8057-agent&lt;/a&gt; которая из зависимостей требует только jre 1.6+ и пока умеет выводить данные в stdout/stderr (для записи в текстовый лог) или работать в интерактивном режиме с ANSI цветами в консоле. На подходе ещё возможность писать в InfluxDB. Готовый jar можно &lt;a href="https://github.com/maizy/ambient7#download"&gt;скачать в github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Про InfluxDB, если удастся с ним подружиться, расскажу отдельно.&lt;/p&gt;</content><category term="scala"></category><category term="hardware"></category><category term="ambient7"></category></entry><entry><title>Шаблонизация с handlebars и json4s на scala</title><link href="https://blog.maizy.ru/posts/handlerbars-templates-in-scala" rel="alternate"></link><published>2015-10-28T00:00:00+03:00</published><updated>2015-10-28T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-10-28:/posts/handlerbars-templates-in-scala</id><summary type="html">&lt;p&gt;Занимаюсь неспешно своим проектом &lt;a href="https://github.com/scala-moscow/"&gt;scala.moscow&lt;/a&gt;. Одна из задач – примитивный генератор статических сайтов. Очень хотелось чего-то простого для шаблонизации. Думал взять mustache, но оказалось, что это уже не совсем модно-молодёжно, так как есть его расширения handlebars и hogan.&lt;/p&gt;
&lt;p&gt;Handlebars мне больше приглянулся. Для scala есть нативная реализация на парсер комбинаторах
&lt;a href="https://github.com/mwunsch/handlebars.scala"&gt;handlebars.scala&lt;/a&gt; и её &lt;a href="https://github.com/gilt/handlebars.scala.fork"&gt;форк&lt;/a&gt;. По фичам scala реализация очень ограничена, в частности, нет встроенной поддержки наследования шаблонов, которая в handlebars делается не силами шаблонизатора, а силами helper'ов. В итоге взял &lt;a href="https://github.com/jknack/handlebars.java"&gt;handlebars.java&lt;/a&gt;, который выглядит достаточно зрелым и имеет в составе, как минимум, helper'ы &lt;code&gt;partial&lt;/code&gt; и &lt;code&gt;block&lt;/code&gt; для наследования и i18n.&lt;/p&gt;
&lt;p&gt;После выбора шаблонизатора встал вопрос как в него загружать данные. Встроенные резолверы не удобно использовать в scala, да и хотелось чего-то более простого, чем создания пачки классов-контейнеров для данных. А что есть проще для описания примитивных структур данных, чем JSON. Для scala нашёлся отличный DSL для JSON - &lt;a href="http://json4s.org/"&gt;json4s&lt;/a&gt;, у которого в частности есть такой лаконичный DSL:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.json4s.JsonDSL._&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;copyright&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;year&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2015&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;assets&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;path&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/assets&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;scala.moscow&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;about&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;about&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;scala.moscow :: о проекте&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Плюс к этому handlebars и задумывался для комбинации с JSON, что отражается в его синтаксисе. Плюс к этому сразу решается вопрос, где хранить статические данные, которые не нужно генерить программно –  в JSON файлах. В json4s конечно есть не только DSL, но и парсеры на основе нативной scala реализации и jackson.&lt;/p&gt;
&lt;p&gt;Чтобы подружить handlebars.java и json4s DSL, написал &lt;a href="https://github.com/scala-moscow/scala.moscow/blob/master/site-generator/src/main/scala/moscow/scala/sitegen/utils/template/JValueResolver.scala"&gt;ValueResolver&lt;/a&gt;, идею и часть реализации подсмотрел у &lt;a href="https://github.com/mfirry/handlebars-json4s/"&gt;handlebars-json4s&lt;/a&gt;, но доработал её, решил часть проблем и дописал тестов. Как решу &lt;a href="https://github.com/scala-moscow/scala.moscow/blob/4d31fad70f7bccd8097de21637f820375af41b52/site-generator/src/test/scala/moscow/scala/sitegen/tests/utils/template/JValueResolverSpec.scala#L86-L93"&gt;оставшиеся проблемы&lt;/a&gt; планирую сделать отдельный артефакт.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Занимаюсь неспешно своим проектом &lt;a href="https://github.com/scala-moscow/"&gt;scala.moscow&lt;/a&gt;. Одна из задач – примитивный генератор статических сайтов. Очень хотелось чего-то простого для шаблонизации. Думал взять mustache, но оказалось, что это уже не совсем модно-молодёжно, так как есть его расширения handlebars и hogan.&lt;/p&gt;
&lt;p&gt;Handlebars мне больше приглянулся. Для scala есть нативная реализация на парсер комбинаторах
&lt;a href="https://github.com/mwunsch/handlebars.scala"&gt;handlebars.scala&lt;/a&gt; и её &lt;a href="https://github.com/gilt/handlebars.scala.fork"&gt;форк&lt;/a&gt;. По фичам scala реализация очень ограничена, в частности, нет встроенной поддержки наследования шаблонов, которая в handlebars делается не силами шаблонизатора, а силами helper'ов. В итоге взял &lt;a href="https://github.com/jknack/handlebars.java"&gt;handlebars.java&lt;/a&gt;, который выглядит достаточно зрелым и имеет в составе, как минимум, helper'ы &lt;code&gt;partial&lt;/code&gt; и &lt;code&gt;block&lt;/code&gt; для наследования и i18n.&lt;/p&gt;
&lt;p&gt;После выбора шаблонизатора встал вопрос как в него загружать данные. Встроенные резолверы не удобно использовать в scala, да и хотелось чего-то более простого, чем создания пачки классов-контейнеров для данных. А что есть проще для описания примитивных структур данных, чем JSON. Для scala нашёлся отличный DSL для JSON - &lt;a href="http://json4s.org/"&gt;json4s&lt;/a&gt;, у которого в частности есть такой лаконичный DSL:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.json4s.JsonDSL._&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;copyright&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;year&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2015&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;assets&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;path&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/assets&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;scala.moscow&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;about&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;about&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;scala.moscow :: о проекте&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Плюс к этому handlebars и задумывался для комбинации с JSON, что отражается в его синтаксисе. Плюс к этому сразу решается вопрос, где хранить статические данные, которые не нужно генерить программно –  в JSON файлах. В json4s конечно есть не только DSL, но и парсеры на основе нативной scala реализации и jackson.&lt;/p&gt;
&lt;p&gt;Чтобы подружить handlebars.java и json4s DSL, написал &lt;a href="https://github.com/scala-moscow/scala.moscow/blob/master/site-generator/src/main/scala/moscow/scala/sitegen/utils/template/JValueResolver.scala"&gt;ValueResolver&lt;/a&gt;, идею и часть реализации подсмотрел у &lt;a href="https://github.com/mfirry/handlebars-json4s/"&gt;handlebars-json4s&lt;/a&gt;, но доработал её, решил часть проблем и дописал тестов. Как решу &lt;a href="https://github.com/scala-moscow/scala.moscow/blob/4d31fad70f7bccd8097de21637f820375af41b52/site-generator/src/test/scala/moscow/scala/sitegen/tests/utils/template/JValueResolverSpec.scala#L86-L93"&gt;оставшиеся проблемы&lt;/a&gt; планирую сделать отдельный артефакт.&lt;/p&gt;</content><category term="scala"></category><category term="scala.moscow"></category></entry><entry><title>Akka. Тестирование в общем и про тестирование кластера в частности</title><link href="https://blog.maizy.ru/posts/akka-cluster-testing" rel="alternate"></link><published>2015-09-21T00:00:00+03:00</published><updated>2015-09-21T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-09-21:/posts/akka-cluster-testing</id><summary type="html">&lt;p&gt;Продолжая заниматься &lt;a href="https://github.com/maizy/akka-cluster-heartbeat"&gt;hello world'ом на akka&lt;/a&gt; погрузился в вопрос тестирования акторов.&lt;/p&gt;
&lt;p&gt;Общие вещи просты, не вижу смысла пересказывать &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html"&gt;документацию&lt;/a&gt;, остановлюсь только на ключевых моментах и выводах.&lt;/p&gt;
&lt;h3&gt;Асинхронное vs синхронное тестирование&lt;/h3&gt;
&lt;p&gt;Есть два подхода &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Synchronous_Unit_Testing_with_TestActorRef"&gt;синхронное&lt;/a&gt; и &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Asynchronous_Integration_Testing_with_TestKit"&gt;асинхронное&lt;/a&gt; тестирование. Первое в реальной жизни почти никогда не нужно, если только не хочется протестировать какие-то уж совсем внутренние кишки актора. В остальных случаях, лучше тестировать честно, отправляя и принимая ответы от акторов.&lt;/p&gt;
&lt;h3&gt;TestProbe и TestActor&lt;/h3&gt;
&lt;p&gt;Часть которую важно понимать. Сначала я думал, что при тестировании будет какая-то чёрная магия, которая позволит мне получать сообщения, летающие между разными акторами.&lt;/p&gt;
&lt;p&gt;На деле всё проще. Внутри вашего TestCase создаётся TestProbe и TestActor, которые затем используются для запросов к акторам и анализа приходящих результатов. К сожалению, в документации сразу показывается пример с trait &lt;code&gt;ImplicitSender&lt;/code&gt;, который слегка "гримирует" наличие testActor, что вызвало по началу повышенное количество wtf-per-line.&lt;/p&gt;
&lt;p&gt;Соответственно &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Built-In_Assertions"&gt;набор стандартных assert'ов&lt;/a&gt; на самом деле вызывается у стандартного TestProbe. Конечно же таких TestProbe можно даже &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Using_Multiple_Probe_Actors"&gt;создать несколько&lt;/a&gt; и, например, поместить в них дополнительные специфичные вам assert'ы.&lt;/p&gt;
&lt;p&gt;Отсюда же вывод, что для тестирования parent-child взаимодействия придётся вставлять между ними тестовый актор с проксированием сообщений, в документации &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Testing_parent-child_relationships"&gt;описаны способы сделать это&lt;/a&gt;. В любом случае production код нужно немного к такому подготовить, другой вопрос, что изменения полезны и для других целей.&lt;/p&gt;
&lt;h3&gt;Cluster testing&lt;/h3&gt;
&lt;p&gt;С тестированием кластерных конфигурацию всё не так тривиально.&lt;/p&gt;
&lt;p&gt;Для начала есть решение &lt;a href="https://github.com/sbt/sbt-multi-jvm"&gt;multi-jvm тестирования с плагином для sbt&lt;/a&gt;, в документации к akka описано как &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html"&gt;это всё подружить с тестами&lt;/a&gt;, чтобы &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html"&gt;получить Multi Node Testing&lt;/a&gt;. Пригодится и для других задач, когда используется просто akka remote.&lt;/p&gt;
&lt;p&gt;Печалит, что нужно &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html#multi-jvm-testing"&gt;серьёзно "испортить" конфиг sbt&lt;/a&gt;, но, наверное, можно решить выносом таких тестов в отдельный sbt проект. Также ваша IntelliJ IDEA по понятным причинам про такие тесты ничего знать не будет, так как всё магия работает только в связке с sbt. Думаю, в ScalaIDE будет аналогично.&lt;/p&gt;
&lt;p&gt;Простого способа дебажить это тоже нет. Логи не очень удобны, так как валяться в параллель со всех JVM. В идеале нужно писать обёртки, которые будут собирать их по каждой ноде отдельно.&lt;/p&gt;
&lt;h3&gt;"... напоминает мне игру: "Что? Где? Когда?" называется! Непонятно, что где валяется и когда все это кончится!"&lt;/h3&gt;
&lt;p&gt;Общерекомендуемый подход писать multi-jvm тесты в одном классе, который будет одинаково выполняться на всех нодах. Это обязывает постоянно следить за тем какой код и где исполняется. Например, написанный в лоб assert будет выполнен на всех нодах, часть из которых может быть ещё не присоединена к кластеру.&lt;/p&gt;
&lt;p&gt;Постоянно об это спотыкался, но потом написал себе пару удобных утилиток:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.collection.mutable&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.scalatest.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;BeforeAndAfterAll&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Matchers&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.Cluster&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.ClusterEvent.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;CurrentClusterState&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.remote.testconductor.RoleName&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.remote.testkit.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeConfig&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpecCallbacks&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.testkit.ImplicitSender&lt;/span&gt;



&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeBaseSpec&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;MultiNodeConfig&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpec&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;BeforeAndAfterAll&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpecCallbacks&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;ImplicitSender&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Matchers&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;beforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;beforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;multiNodeSpecBeforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;afterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before-clean-up&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;cleanUp&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;clean-up&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;multiNodeSpecAfterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;afterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Cluster&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Cluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testActor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
  &lt;span class="n"&gt;expectMsgClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;CurrentClusterState&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s&amp;quot;myself address: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myself&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;, role: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;myself&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mutable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;]()&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;joinToCluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Seq&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;seedNode&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="o"&gt;++=&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;
    &lt;span class="c1"&gt;// on new nodes await events for all cluster member&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;cluster&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seedNode&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiveN&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;
        &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;contain&lt;/span&gt; &lt;span class="n"&gt;theSameElementsAs&lt;/span&gt; &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// on existing nodes await events for only new cluster members&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiveN&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;
        &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;contain&lt;/span&gt; &lt;span class="n"&gt;theSameElementsAs&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;join-&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;mkString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;runOnJoinedNodes&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;a&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cleanUp&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unsubscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testActor&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В базовом spec'е выше реализовано:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;подписывание на события кластера&lt;/li&gt;
&lt;li&gt;метод &lt;code&gt;joinToCluster&lt;/code&gt; для правильного присоединения к кластеру нод&lt;/li&gt;
&lt;li&gt;метод &lt;code&gt;runOnJoinedNodes&lt;/code&gt; для выполнения кода на уже работающих нодах кластера, аналогичный по использованию &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html#A_Multi_Node_Testing_Example"&gt;встроенному &lt;code&gt;runOn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Тестирование сети&lt;/h3&gt;
&lt;p&gt;Есть встроенная поддержка тестирования транспорта и сети с возможностью эмуляции проблем между нодами (blackhole). При этом я надеюсь как-нибудь попробовать приспособить docker, его API и iptables для данных целей, благо multi-jvm, кажется умеет сам в тестах упаковывать тестовую ноду в jar, раскладывать через ssh+rsync, а затем запускать.&lt;/p&gt;
&lt;h3&gt;Примеры&lt;/h3&gt;
&lt;p&gt;Можно глянуть, что &lt;a href="https://github.com/maizy/akka-cluster-heartbeat/tree/master/src/multi-jvm/scala"&gt;получилось у меня&lt;/a&gt;. Много полезных примеров я обнаружил в &lt;a href="https://github.com/akka/akka/tree/master/akka-cluster/src/multi-jvm/scala/akka/cluster"&gt;самих исходниках akka&lt;/a&gt; и &lt;a href="https://github.com/jboner/akka-crdt/tree/master/src/multi-jvm/scala/akka/crdt/convergent"&gt;в проекте akka crdt&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Вывод&lt;/h3&gt;
&lt;p&gt;Тестировать akka, даже в сложных конфигурациях можно и нужно, но tooling ещё требует доработки.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Продолжая заниматься &lt;a href="https://github.com/maizy/akka-cluster-heartbeat"&gt;hello world'ом на akka&lt;/a&gt; погрузился в вопрос тестирования акторов.&lt;/p&gt;
&lt;p&gt;Общие вещи просты, не вижу смысла пересказывать &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html"&gt;документацию&lt;/a&gt;, остановлюсь только на ключевых моментах и выводах.&lt;/p&gt;
&lt;h3&gt;Асинхронное vs синхронное тестирование&lt;/h3&gt;
&lt;p&gt;Есть два подхода &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Synchronous_Unit_Testing_with_TestActorRef"&gt;синхронное&lt;/a&gt; и &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Asynchronous_Integration_Testing_with_TestKit"&gt;асинхронное&lt;/a&gt; тестирование. Первое в реальной жизни почти никогда не нужно, если только не хочется протестировать какие-то уж совсем внутренние кишки актора. В остальных случаях, лучше тестировать честно, отправляя и принимая ответы от акторов.&lt;/p&gt;
&lt;h3&gt;TestProbe и TestActor&lt;/h3&gt;
&lt;p&gt;Часть которую важно понимать. Сначала я думал, что при тестировании будет какая-то чёрная магия, которая позволит мне получать сообщения, летающие между разными акторами.&lt;/p&gt;
&lt;p&gt;На деле всё проще. Внутри вашего TestCase создаётся TestProbe и TestActor, которые затем используются для запросов к акторам и анализа приходящих результатов. К сожалению, в документации сразу показывается пример с trait &lt;code&gt;ImplicitSender&lt;/code&gt;, который слегка "гримирует" наличие testActor, что вызвало по началу повышенное количество wtf-per-line.&lt;/p&gt;
&lt;p&gt;Соответственно &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Built-In_Assertions"&gt;набор стандартных assert'ов&lt;/a&gt; на самом деле вызывается у стандартного TestProbe. Конечно же таких TestProbe можно даже &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Using_Multiple_Probe_Actors"&gt;создать несколько&lt;/a&gt; и, например, поместить в них дополнительные специфичные вам assert'ы.&lt;/p&gt;
&lt;p&gt;Отсюда же вывод, что для тестирования parent-child взаимодействия придётся вставлять между ними тестовый актор с проксированием сообщений, в документации &lt;a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Testing_parent-child_relationships"&gt;описаны способы сделать это&lt;/a&gt;. В любом случае production код нужно немного к такому подготовить, другой вопрос, что изменения полезны и для других целей.&lt;/p&gt;
&lt;h3&gt;Cluster testing&lt;/h3&gt;
&lt;p&gt;С тестированием кластерных конфигурацию всё не так тривиально.&lt;/p&gt;
&lt;p&gt;Для начала есть решение &lt;a href="https://github.com/sbt/sbt-multi-jvm"&gt;multi-jvm тестирования с плагином для sbt&lt;/a&gt;, в документации к akka описано как &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html"&gt;это всё подружить с тестами&lt;/a&gt;, чтобы &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html"&gt;получить Multi Node Testing&lt;/a&gt;. Пригодится и для других задач, когда используется просто akka remote.&lt;/p&gt;
&lt;p&gt;Печалит, что нужно &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html#multi-jvm-testing"&gt;серьёзно "испортить" конфиг sbt&lt;/a&gt;, но, наверное, можно решить выносом таких тестов в отдельный sbt проект. Также ваша IntelliJ IDEA по понятным причинам про такие тесты ничего знать не будет, так как всё магия работает только в связке с sbt. Думаю, в ScalaIDE будет аналогично.&lt;/p&gt;
&lt;p&gt;Простого способа дебажить это тоже нет. Логи не очень удобны, так как валяться в параллель со всех JVM. В идеале нужно писать обёртки, которые будут собирать их по каждой ноде отдельно.&lt;/p&gt;
&lt;h3&gt;"... напоминает мне игру: "Что? Где? Когда?" называется! Непонятно, что где валяется и когда все это кончится!"&lt;/h3&gt;
&lt;p&gt;Общерекомендуемый подход писать multi-jvm тесты в одном классе, который будет одинаково выполняться на всех нодах. Это обязывает постоянно следить за тем какой код и где исполняется. Например, написанный в лоб assert будет выполнен на всех нодах, часть из которых может быть ещё не присоединена к кластеру.&lt;/p&gt;
&lt;p&gt;Постоянно об это спотыкался, но потом написал себе пару удобных утилиток:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.collection.mutable&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.scalatest.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;BeforeAndAfterAll&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Matchers&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.Cluster&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.ClusterEvent.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;CurrentClusterState&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.remote.testconductor.RoleName&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.remote.testkit.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpec&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeConfig&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpecCallbacks&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.testkit.ImplicitSender&lt;/span&gt;



&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeBaseSpec&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;MultiNodeConfig&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpec&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;BeforeAndAfterAll&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;MultiNodeSpecCallbacks&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;ImplicitSender&lt;/span&gt;
  &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Matchers&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;beforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;beforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;multiNodeSpecBeforeAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;afterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;before-clean-up&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;cleanUp&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;clean-up&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;multiNodeSpecAfterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;afterAll&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Cluster&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Cluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testActor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
  &lt;span class="n"&gt;expectMsgClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;CurrentClusterState&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s&amp;quot;myself address: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myself&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;, role: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;myself&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mutable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Set&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;]()&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;joinToCluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Seq&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;seedNode&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;RoleName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="o"&gt;++=&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;
    &lt;span class="c1"&gt;// on new nodes await events for all cluster member&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;cluster&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seedNode&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiveN&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;
        &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;contain&lt;/span&gt; &lt;span class="n"&gt;theSameElementsAs&lt;/span&gt; &lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// on existing nodes await events for only new cluster members&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiveN&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;collect&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;MemberUp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;
        &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;contain&lt;/span&gt; &lt;span class="n"&gt;theSameElementsAs&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toSet&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;enterBarrier&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;join-&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;mkString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;runOnJoinedNodes&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;runOn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentClusterNodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="kt"&gt;*&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;a&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;cleanUp&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="n"&gt;cluster&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unsubscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testActor&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;В базовом spec'е выше реализовано:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;подписывание на события кластера&lt;/li&gt;
&lt;li&gt;метод &lt;code&gt;joinToCluster&lt;/code&gt; для правильного присоединения к кластеру нод&lt;/li&gt;
&lt;li&gt;метод &lt;code&gt;runOnJoinedNodes&lt;/code&gt; для выполнения кода на уже работающих нодах кластера, аналогичный по использованию &lt;a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html#A_Multi_Node_Testing_Example"&gt;встроенному &lt;code&gt;runOn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Тестирование сети&lt;/h3&gt;
&lt;p&gt;Есть встроенная поддержка тестирования транспорта и сети с возможностью эмуляции проблем между нодами (blackhole). При этом я надеюсь как-нибудь попробовать приспособить docker, его API и iptables для данных целей, благо multi-jvm, кажется умеет сам в тестах упаковывать тестовую ноду в jar, раскладывать через ssh+rsync, а затем запускать.&lt;/p&gt;
&lt;h3&gt;Примеры&lt;/h3&gt;
&lt;p&gt;Можно глянуть, что &lt;a href="https://github.com/maizy/akka-cluster-heartbeat/tree/master/src/multi-jvm/scala"&gt;получилось у меня&lt;/a&gt;. Много полезных примеров я обнаружил в &lt;a href="https://github.com/akka/akka/tree/master/akka-cluster/src/multi-jvm/scala/akka/cluster"&gt;самих исходниках akka&lt;/a&gt; и &lt;a href="https://github.com/jboner/akka-crdt/tree/master/src/multi-jvm/scala/akka/crdt/convergent"&gt;в проекте akka crdt&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Вывод&lt;/h3&gt;
&lt;p&gt;Тестировать akka, даже в сложных конфигурациях можно и нужно, но tooling ещё требует доработки.&lt;/p&gt;</content><category term="akka"></category><category term="scala"></category></entry><entry><title>FPConf 2015 - заметки на полях</title><link href="https://blog.maizy.ru/posts/fpconf-2015" rel="alternate"></link><published>2015-08-17T00:00:00+03:00</published><updated>2015-08-17T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-08-17:/posts/fpconf-2015</id><summary type="html">&lt;p&gt;Побывал на конференции &lt;a href="http://fpconf.ru/"&gt;FPConf&lt;/a&gt;. Поделюсь своими мыслями, возникшими при прослушивании докладов. Я в основном сидел на втором потоке, где было про scala, UI и пр. Первый поток был преимущественно про Erlang и Haskell.&lt;/p&gt;
&lt;p&gt;&lt;s&gt;Организаторы обещали, что будет видео, надеюсь пополнить эту статью ссылкам в будущем.&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;Upd 09.12.2015: дополнил.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=Pu3D5GQ6UEg"&gt;Cамурайский путь молодого scala-программиста, Сергей Лобин, Sputnik.ru&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;В докладе было мало про scala, больше про проблемы при разработки геокодера в Спутнике. Главный печальный для всех фанатов Scala вывод – Scala в production и них не прижилась, найти разработчиков сложно, Go разработчиков найти значительно проще.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=xd2xtQ61zKo"&gt;Макросы scala, Михаил Муцянко, JetBrains&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хороший вводный доклад про макросы Scala от разработчика &lt;a href="http://blog.jetbrains.com/scala/"&gt;Scala plugin в IDEA&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Из запомнившегося:&lt;/p&gt;
&lt;p&gt;Удобный способ построения AST в макросе через &lt;a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html"&gt;Q интерполятор&lt;/a&gt; (квазикватирование).&lt;/p&gt;
&lt;p&gt;Килер фича, когда Михаил нажатием одной волшебной кнопки прямо в IDEA, показал как разворачивается макрос в Scala код. К сожалению оказалось, что это не из production версии плагина и вроде ожидать такое в ближайшее время не стоит, так как работает не всегда корректно. Очень вкусная возможность, будем ждать.&lt;/p&gt;
&lt;p&gt;В 2.12 ожидается значительное улучшение в деле разработки макросов за счёт нового проекта &lt;a href="http://scalameta.org/"&gt;ScalaMeta&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Хорошая ссылка на изучение: What Are Macros Good For? от Евгения Бурмако &lt;a href="http://www.youtube.com/watch?v=4Rxo_7lrb7Y"&gt;YouTube&lt;/a&gt;, &lt;a href="http://scalamacros.org/paperstalks/2013-07-17-WhatAreMacrosGoodFor.pdf"&gt;слайды&lt;/a&gt;. BTW про самого Евгения и его работу над Scala макросами можно узнать в &lt;a href="http://eax.me/eaxcast-s02e10/"&gt;EaxCast S02E10&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Доклад рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=q6H7T-8GOLk"&gt;Встраивание языка в строковой интерполятор, Михаил Лиманский, ЭСК&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хороший практический доклад, как вместо DSL порой можно обойтись интерполятором. Какие возможности, плюсы и минусы такого подхода. Можно прямо брать доклад и писать свой интерполятор как по tutorial'у.&lt;/p&gt;
&lt;p&gt;В качестве домашнего задания для себя запомнил задачу реализовать интерполятор для типобезопасного форматирования строки. Хотим с &lt;a href="http://habrahabr.ru/users/aveic/"&gt;aveic&lt;/a&gt; попробовать независимо друг от друга реализовать это и посмотреть, что получиться.&lt;/p&gt;
&lt;p&gt;Рекомендую для тех, кто интересуется темой.&lt;/p&gt;
&lt;h3&gt;Lenses And Prisms, Эдвард Кметт&lt;/h3&gt;
&lt;p&gt;Самый звёздный докладчик на конференции. К сожалению без знания хотя бы основ синтаксиса Haskell понять что-то было сложно. Докладчик проводил доклад в потрясающей форме - выдавая как из пулемёта кучу кода на Haskell прями в vim'е.&lt;/p&gt;
&lt;p&gt;Чтобы понять что к чему, я смотрел на порт этой библиотеки на Scala - &lt;a href="https://github.com/julien-truffaut/Monocle"&gt;Monocle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В общих словах – это удобный способ изменения иммутабельных структур с возможностью написания максимально абстрактных маленьких кусочков с дальнейшим комбинированием в более сложные кусочки.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Видео к сожалению не выложили.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=Ev6diAO2FAI"&gt;Реактивные потоки в backend-е, Алексей Романчук, 2ГИС&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хорошая success story про использование akka streams в production. Для меня теперь это один из ответов на вопрос «где нам нужна akka?».&lt;/p&gt;
&lt;p&gt;Забавные слайды с цветными "сосиками".&lt;/p&gt;
&lt;p&gt;Прозвучавшее число потерь на akka streams по сравнению с голыми акторами ~10%.&lt;/p&gt;
&lt;p&gt;Рекомендую всем, кому интересны akka streams.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=__PLkxx6Yko"&gt;Scala performance для сомневающихся, Роман Гребенников, Sociohub.ru&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Самый запомнившийся доклад. Покрывает сразу две темы - пару примеров того как все модные молодёжные FP штуки из scala отражаются в bytecode JVM и машинном коде, какие потери они за собой несут или не несут. А также способы самому развернуть, померить и понять как выполняется тот или иной код.&lt;/p&gt;
&lt;p&gt;Вкратце про проблемы – простой pattern matching по типу параметра - также быстро как колбаса из if'ов. Есть проблемы с boxing/unboxing в Scala collection и прикладывать &lt;a href="http://www.scala-lang.org/api/2.11.4/index.html#scala.specialized"&gt;@specialized&lt;/a&gt; не поможет.&lt;/p&gt;
&lt;p&gt;Рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;В общем&lt;/h3&gt;
&lt;p&gt;Очень приятное послевкусие от конференции, не ожидал, что про FP будет так целостно. Как сказали организаторы было 180 человек.&lt;/p&gt;
&lt;p&gt;Не посмотрел в живую &lt;a href="http://www.youtube.com/watch?v=cRWrrHPrk9g"&gt;«Фронтэнд без грусти» Никиты Прокопова&lt;/a&gt;, о котором наслышан от коллег, которые видели доклад на какой-то другой конференции. А также хочется поглядеть на &lt;a href="http://www.youtube.com/watch?v=w8D6Ibo_TDQ"&gt;«Aрхитектура UI на основе функциональных линз» от Ильи Беда&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;s&gt;Буду ждать видео.&lt;/s&gt; Дождались.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Побывал на конференции &lt;a href="http://fpconf.ru/"&gt;FPConf&lt;/a&gt;. Поделюсь своими мыслями, возникшими при прослушивании докладов. Я в основном сидел на втором потоке, где было про scala, UI и пр. Первый поток был преимущественно про Erlang и Haskell.&lt;/p&gt;
&lt;p&gt;&lt;s&gt;Организаторы обещали, что будет видео, надеюсь пополнить эту статью ссылкам в будущем.&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;Upd 09.12.2015: дополнил.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=Pu3D5GQ6UEg"&gt;Cамурайский путь молодого scala-программиста, Сергей Лобин, Sputnik.ru&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;В докладе было мало про scala, больше про проблемы при разработки геокодера в Спутнике. Главный печальный для всех фанатов Scala вывод – Scala в production и них не прижилась, найти разработчиков сложно, Go разработчиков найти значительно проще.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=xd2xtQ61zKo"&gt;Макросы scala, Михаил Муцянко, JetBrains&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хороший вводный доклад про макросы Scala от разработчика &lt;a href="http://blog.jetbrains.com/scala/"&gt;Scala plugin в IDEA&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Из запомнившегося:&lt;/p&gt;
&lt;p&gt;Удобный способ построения AST в макросе через &lt;a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html"&gt;Q интерполятор&lt;/a&gt; (квазикватирование).&lt;/p&gt;
&lt;p&gt;Килер фича, когда Михаил нажатием одной волшебной кнопки прямо в IDEA, показал как разворачивается макрос в Scala код. К сожалению оказалось, что это не из production версии плагина и вроде ожидать такое в ближайшее время не стоит, так как работает не всегда корректно. Очень вкусная возможность, будем ждать.&lt;/p&gt;
&lt;p&gt;В 2.12 ожидается значительное улучшение в деле разработки макросов за счёт нового проекта &lt;a href="http://scalameta.org/"&gt;ScalaMeta&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Хорошая ссылка на изучение: What Are Macros Good For? от Евгения Бурмако &lt;a href="http://www.youtube.com/watch?v=4Rxo_7lrb7Y"&gt;YouTube&lt;/a&gt;, &lt;a href="http://scalamacros.org/paperstalks/2013-07-17-WhatAreMacrosGoodFor.pdf"&gt;слайды&lt;/a&gt;. BTW про самого Евгения и его работу над Scala макросами можно узнать в &lt;a href="http://eax.me/eaxcast-s02e10/"&gt;EaxCast S02E10&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Доклад рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=q6H7T-8GOLk"&gt;Встраивание языка в строковой интерполятор, Михаил Лиманский, ЭСК&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хороший практический доклад, как вместо DSL порой можно обойтись интерполятором. Какие возможности, плюсы и минусы такого подхода. Можно прямо брать доклад и писать свой интерполятор как по tutorial'у.&lt;/p&gt;
&lt;p&gt;В качестве домашнего задания для себя запомнил задачу реализовать интерполятор для типобезопасного форматирования строки. Хотим с &lt;a href="http://habrahabr.ru/users/aveic/"&gt;aveic&lt;/a&gt; попробовать независимо друг от друга реализовать это и посмотреть, что получиться.&lt;/p&gt;
&lt;p&gt;Рекомендую для тех, кто интересуется темой.&lt;/p&gt;
&lt;h3&gt;Lenses And Prisms, Эдвард Кметт&lt;/h3&gt;
&lt;p&gt;Самый звёздный докладчик на конференции. К сожалению без знания хотя бы основ синтаксиса Haskell понять что-то было сложно. Докладчик проводил доклад в потрясающей форме - выдавая как из пулемёта кучу кода на Haskell прями в vim'е.&lt;/p&gt;
&lt;p&gt;Чтобы понять что к чему, я смотрел на порт этой библиотеки на Scala - &lt;a href="https://github.com/julien-truffaut/Monocle"&gt;Monocle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В общих словах – это удобный способ изменения иммутабельных структур с возможностью написания максимально абстрактных маленьких кусочков с дальнейшим комбинированием в более сложные кусочки.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Видео к сожалению не выложили.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=Ev6diAO2FAI"&gt;Реактивные потоки в backend-е, Алексей Романчук, 2ГИС&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Хорошая success story про использование akka streams в production. Для меня теперь это один из ответов на вопрос «где нам нужна akka?».&lt;/p&gt;
&lt;p&gt;Забавные слайды с цветными "сосиками".&lt;/p&gt;
&lt;p&gt;Прозвучавшее число потерь на akka streams по сравнению с голыми акторами ~10%.&lt;/p&gt;
&lt;p&gt;Рекомендую всем, кому интересны akka streams.&lt;/p&gt;
&lt;h3&gt;&lt;a href="http://www.youtube.com/watch?v=__PLkxx6Yko"&gt;Scala performance для сомневающихся, Роман Гребенников, Sociohub.ru&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Самый запомнившийся доклад. Покрывает сразу две темы - пару примеров того как все модные молодёжные FP штуки из scala отражаются в bytecode JVM и машинном коде, какие потери они за собой несут или не несут. А также способы самому развернуть, померить и понять как выполняется тот или иной код.&lt;/p&gt;
&lt;p&gt;Вкратце про проблемы – простой pattern matching по типу параметра - также быстро как колбаса из if'ов. Есть проблемы с boxing/unboxing в Scala collection и прикладывать &lt;a href="http://www.scala-lang.org/api/2.11.4/index.html#scala.specialized"&gt;@specialized&lt;/a&gt; не поможет.&lt;/p&gt;
&lt;p&gt;Рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;В общем&lt;/h3&gt;
&lt;p&gt;Очень приятное послевкусие от конференции, не ожидал, что про FP будет так целостно. Как сказали организаторы было 180 человек.&lt;/p&gt;
&lt;p&gt;Не посмотрел в живую &lt;a href="http://www.youtube.com/watch?v=cRWrrHPrk9g"&gt;«Фронтэнд без грусти» Никиты Прокопова&lt;/a&gt;, о котором наслышан от коллег, которые видели доклад на какой-то другой конференции. А также хочется поглядеть на &lt;a href="http://www.youtube.com/watch?v=w8D6Ibo_TDQ"&gt;«Aрхитектура UI на основе функциональных линз» от Ильи Беда&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;s&gt;Буду ждать видео.&lt;/s&gt; Дождались.&lt;/p&gt;</content><category term="conference"></category><category term="scala"></category></entry><entry><title>Akka graceful shutdown и обработка системных сигналов</title><link href="https://blog.maizy.ru/posts/akka-graceful-shutdown" rel="alternate"></link><published>2015-08-06T00:00:00+03:00</published><updated>2015-08-06T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-08-06:/posts/akka-graceful-shutdown</id><summary type="html">&lt;p&gt;Когда начал писать для себя &lt;a href="https://github.com/maizy/akka-cluster-heartbeat"&gt;hello world на akka&lt;/a&gt; сразу захотелось сделать какой-то артефакт, удобный для жизни в дикой среде production. Хочется, чтобы приложение вело себя как примерный гражданин, умело правильно реагировать на всякие системные сигналы и прочее.&lt;/p&gt;
&lt;p&gt;С упаковкой приложения в jar вместе с scala runtime удалось легко разобраться. Помогут &lt;code&gt;sbt-native-packager&lt;/code&gt; и &lt;code&gt;sbt-assembly&lt;/code&gt;. Напишу про это позже, когда ещё пойму как правильно результат сложить в .deb пакет.&lt;/p&gt;
&lt;p&gt;Не сразу почему-то удалось сделать правильные реагирования на сигналы системы. Меня пока не интересуют всякие специфичные штуки, достаточно было двух сигналов выключения - SIGINT и SIGTERM, по которым хотелось аккуратно потушить ноду в akka cluster - убить её локальные акторы, отсоединиться и пр.&lt;/p&gt;
&lt;p&gt;Сначала попробовал использовать модный_молодёжный метод &lt;a href="http://www.scala-lang.org/api/current/index.html#scala.sys.package@addShutdownHook(body:=&amp;gt;Unit):scala.sys.ShutdownHookThread"&gt;scala.sys.addShutdownHook&lt;/a&gt;. Он принимает &lt;code&gt;=&amp;gt; Unit&lt;/code&gt; и выполняет его в отдельном треде, когда завершается jvm. Вызов не гарантируется, что в данном случае ок. Плюс метода - переносимость. Минус - код возврата не возможно поставить, метод &lt;code&gt;System.exit()&lt;/code&gt; выполняется, но код не ставиться. Экспериментально понял, что на SIGINT код всегда 130, на SIGTERM - 146. Вторая проблема - akka при выключении часть логов пишет в stdout, которые при использовании хука уже не выводятся. Не проверял, но кажется stdout закрывается раньше, чем вызывается этот хук.&lt;/p&gt;
&lt;p&gt;Пришлось взять в руки обработчик сигналов и делать на нём. Он из пакета &lt;code&gt;sun.misc&lt;/code&gt;, так что с альтернативными jvm могут быть вопросы, но меня это не волнует в данный момент.&lt;/p&gt;
&lt;p&gt;В итоге метод выглядит примерно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.concurrent.atomic.AtomicBoolean&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sun.misc.SignalHandler&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sun.misc.Signal&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.concurrent.duration._&lt;/span&gt;

&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.typesafe.config.ConfigFactory&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.Cluster&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.actor.ActorSystem&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.util.Timeout&lt;/span&gt;

&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;SignalHandler&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;SIGING&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;INT&amp;quot;&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;SIGTERM&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;TERM&amp;quot;&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;terminated&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AtomicBoolean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;// регистрируем сам App объект, как обработчик сигналов&lt;/span&gt;
  &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGING&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGTERM&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;ConfigFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;ActorSystem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;executionContext&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dispatcher&lt;/span&gt;
  &lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;defaultTimeout&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Timeout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;500.&lt;/span&gt;&lt;span class="n"&gt;millis&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;cluster&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Cluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;//hook для akka, будет использоваться для любых остановок, не только по сигналам&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;registerOnTermination&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// собственно обработчик&lt;/span&gt;
  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareAndSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGING&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;SIGTERM&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shutdown&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Теперь и сигналы честно обрабатываются, и коды возвратов правильные, и все выходы из приложения сводятся в хук для akka.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Когда начал писать для себя &lt;a href="https://github.com/maizy/akka-cluster-heartbeat"&gt;hello world на akka&lt;/a&gt; сразу захотелось сделать какой-то артефакт, удобный для жизни в дикой среде production. Хочется, чтобы приложение вело себя как примерный гражданин, умело правильно реагировать на всякие системные сигналы и прочее.&lt;/p&gt;
&lt;p&gt;С упаковкой приложения в jar вместе с scala runtime удалось легко разобраться. Помогут &lt;code&gt;sbt-native-packager&lt;/code&gt; и &lt;code&gt;sbt-assembly&lt;/code&gt;. Напишу про это позже, когда ещё пойму как правильно результат сложить в .deb пакет.&lt;/p&gt;
&lt;p&gt;Не сразу почему-то удалось сделать правильные реагирования на сигналы системы. Меня пока не интересуют всякие специфичные штуки, достаточно было двух сигналов выключения - SIGINT и SIGTERM, по которым хотелось аккуратно потушить ноду в akka cluster - убить её локальные акторы, отсоединиться и пр.&lt;/p&gt;
&lt;p&gt;Сначала попробовал использовать модный_молодёжный метод &lt;a href="http://www.scala-lang.org/api/current/index.html#scala.sys.package@addShutdownHook(body:=&amp;gt;Unit):scala.sys.ShutdownHookThread"&gt;scala.sys.addShutdownHook&lt;/a&gt;. Он принимает &lt;code&gt;=&amp;gt; Unit&lt;/code&gt; и выполняет его в отдельном треде, когда завершается jvm. Вызов не гарантируется, что в данном случае ок. Плюс метода - переносимость. Минус - код возврата не возможно поставить, метод &lt;code&gt;System.exit()&lt;/code&gt; выполняется, но код не ставиться. Экспериментально понял, что на SIGINT код всегда 130, на SIGTERM - 146. Вторая проблема - akka при выключении часть логов пишет в stdout, которые при использовании хука уже не выводятся. Не проверял, но кажется stdout закрывается раньше, чем вызывается этот хук.&lt;/p&gt;
&lt;p&gt;Пришлось взять в руки обработчик сигналов и делать на нём. Он из пакета &lt;code&gt;sun.misc&lt;/code&gt;, так что с альтернативными jvm могут быть вопросы, но меня это не волнует в данный момент.&lt;/p&gt;
&lt;p&gt;В итоге метод выглядит примерно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.concurrent.atomic.AtomicBoolean&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sun.misc.SignalHandler&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sun.misc.Signal&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.concurrent.duration._&lt;/span&gt;

&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.typesafe.config.ConfigFactory&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.Cluster&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.actor.ActorSystem&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.util.Timeout&lt;/span&gt;

&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;SignalHandler&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;SIGING&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;INT&amp;quot;&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;SIGTERM&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;TERM&amp;quot;&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;terminated&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AtomicBoolean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;// регистрируем сам App объект, как обработчик сигналов&lt;/span&gt;
  &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGING&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGTERM&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;ConfigFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;ActorSystem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;executionContext&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dispatcher&lt;/span&gt;
  &lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;defaultTimeout&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Timeout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;500.&lt;/span&gt;&lt;span class="n"&gt;millis&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;cluster&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Cluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;//hook для akka, будет использоваться для любых остановок, не только по сигналам&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;registerOnTermination&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// собственно обработчик&lt;/span&gt;
  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareAndSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGING&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;SIGTERM&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shutdown&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Теперь и сигналы честно обрабатываются, и коды возвратов правильные, и все выходы из приложения сводятся в хук для akka.&lt;/p&gt;</content><category term="akka"></category><category term="devops"></category></entry><entry><title>Akka для распределённых приложений - remote vs cluster</title><link href="https://blog.maizy.ru/posts/akka-remote-n-cluster" rel="alternate"></link><published>2015-07-20T00:00:00+03:00</published><updated>2015-07-20T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-07-20:/posts/akka-remote-n-cluster</id><summary type="html">&lt;p&gt;Буду делать небольшие заметки на полях по результатам изучения akka.&lt;/p&gt;
&lt;p&gt;Akka – это система акторов на jvm, реализованная на scala. Можно использовать и из java. Про саму концепцию акторов можно почитать в &lt;a href="https://ru.wikipedia.org/wiki/Модель_акторов"&gt;интернетах&lt;/a&gt;, здесь я буду останавливаться на особенностях akka.&lt;/p&gt;
&lt;h3&gt;Что читать?&lt;/h3&gt;
&lt;p&gt;Я пока рекомендую такие источники:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://akka.io/docs/"&gt;официальная документация&lt;/a&gt; - она хорошая, содержит как теоретические основы, так и конкретные примеры кода и описания API. Можно читать из начала в конец, как книгу. Есть &lt;a href="http://doc.akka.io/docs/akka/2.3.12/AkkaScala.pdf"&gt;pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"Akka in Action" by Raymond Roestenburg, Rob Bakker, and Rob Williams - неплохая книга. Я читаю 16 MEAP (early access), к осени-зиме 2015 обещают релиз. &lt;a href="http://www.manning.com/roestenburg/"&gt;Цена 40$&lt;/a&gt;. В основном ориентируюсь на документацию, но в книге  плюс - итеративный подход к реализации демо проекта. Начинают с hello world'ов и далее по нарастающей. Было полезно, когда хотелось быстрого старта без изучения всех тонкостей теории.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stack Overflow - как всегда стоит делать аккуратно. Фреймворк активно развивается, некоторые вещи появляются, которые раньше нужно было самому велосипедить, некоторые становятся deprecated и пр., но есть не мало полезных объяснений.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Googling по тонким вопросам и непоняткам, который нередко приводит в google группу akka.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если жалко 40$, то книгу можно не покупать. Благородя Typesafe хайпа в сети по akka хватает. Для фреймворка – это хорошо.&lt;/p&gt;
&lt;h3&gt;Применимость&lt;/h3&gt;
&lt;p&gt;Меня akka интересует в основном с точки зрения распределённых систем.
Однако akka работает и на одной jvm. Даже есть &lt;a href="http://engineering.intenthq.com/2015/06/wikidata-akka-streams/"&gt;успешные кейсы&lt;/a&gt;, когда в такой подход даёт выигрыш в противовес обычным многопоточным потокам.&lt;/p&gt;
&lt;p&gt;При этом akka имеет грамотный подход – реализации работы различных механизмов по сети ставиться во главу угла, а локальная работа рассматривается, как один из способов оптимизации.&lt;/p&gt;
&lt;h3&gt;remote vs cluster&lt;/h3&gt;
&lt;p&gt;В akka есть понятие "&lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/remoting.html"&gt;akka remote&lt;/a&gt;" – это возможность работать с любыми акторами прозрачно, не зная, где именно они находятся - локально или удалённо. Вы должны каким-либо образом знать, как до этих акторов добраться и эта реализация на вашей ответственности.&lt;/p&gt;
&lt;p&gt;Поверх akka remote строиться &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html"&gt;akka cluster&lt;/a&gt;, который реализует кластерное решение, т.е. количество нод может динамически меняться, каждой ноде может быть назначена роль, которую она исполняет в системе.&lt;/p&gt;
&lt;p&gt;Ноды договариваются с друг другом по &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#Gossip"&gt;gossip протоколу&lt;/a&gt; и внутри используют для хранения состояния CRDT структуры. Одна из нод назначается мастером, если она погасла мастером станет автоматически другая нода.&lt;/p&gt;
&lt;p&gt;Гашение нод вы определяете сами, система только говорит, что нода стала не доступна, вы сами можете решить, что делать - удалять её из кластера или нет. Есть стандартная реализация, когда нода удаляется после недоступности в течении какого-то времени.&lt;/p&gt;
&lt;p&gt;На события кластера, или более точно на жизненный цикл его нод, &lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/cluster-usage.html#A_Simple_Cluster_Example"&gt;можно подписаться&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Некоторые вещи в akka cluster ещё только в &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#niy"&gt;планах на реализацию&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Нет встроенного механизма сказать кластеру "я запустился", у ноды при старте должен быть список seed нод, хотя бы одна из которых должна работать. Seed нодой может быть любая нода работающего кластера. Т.е. в реальной жизни тут нужно будет брать какие-то решения для discovery. Как вариант предлагают также держать ноды, которые ничего не делают (не запускают пользовательские акторы), а только используются как seed ноды.&lt;/p&gt;
&lt;p&gt;Пока всё. Некоторые из аспектов описанных выше я буду изучать подробнее и ещё про них напишу. Если найдёте в моих записях ошибки, буду раз замечаниям.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Буду делать небольшие заметки на полях по результатам изучения akka.&lt;/p&gt;
&lt;p&gt;Akka – это система акторов на jvm, реализованная на scala. Можно использовать и из java. Про саму концепцию акторов можно почитать в &lt;a href="https://ru.wikipedia.org/wiki/Модель_акторов"&gt;интернетах&lt;/a&gt;, здесь я буду останавливаться на особенностях akka.&lt;/p&gt;
&lt;h3&gt;Что читать?&lt;/h3&gt;
&lt;p&gt;Я пока рекомендую такие источники:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://akka.io/docs/"&gt;официальная документация&lt;/a&gt; - она хорошая, содержит как теоретические основы, так и конкретные примеры кода и описания API. Можно читать из начала в конец, как книгу. Есть &lt;a href="http://doc.akka.io/docs/akka/2.3.12/AkkaScala.pdf"&gt;pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"Akka in Action" by Raymond Roestenburg, Rob Bakker, and Rob Williams - неплохая книга. Я читаю 16 MEAP (early access), к осени-зиме 2015 обещают релиз. &lt;a href="http://www.manning.com/roestenburg/"&gt;Цена 40$&lt;/a&gt;. В основном ориентируюсь на документацию, но в книге  плюс - итеративный подход к реализации демо проекта. Начинают с hello world'ов и далее по нарастающей. Было полезно, когда хотелось быстрого старта без изучения всех тонкостей теории.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stack Overflow - как всегда стоит делать аккуратно. Фреймворк активно развивается, некоторые вещи появляются, которые раньше нужно было самому велосипедить, некоторые становятся deprecated и пр., но есть не мало полезных объяснений.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Googling по тонким вопросам и непоняткам, который нередко приводит в google группу akka.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если жалко 40$, то книгу можно не покупать. Благородя Typesafe хайпа в сети по akka хватает. Для фреймворка – это хорошо.&lt;/p&gt;
&lt;h3&gt;Применимость&lt;/h3&gt;
&lt;p&gt;Меня akka интересует в основном с точки зрения распределённых систем.
Однако akka работает и на одной jvm. Даже есть &lt;a href="http://engineering.intenthq.com/2015/06/wikidata-akka-streams/"&gt;успешные кейсы&lt;/a&gt;, когда в такой подход даёт выигрыш в противовес обычным многопоточным потокам.&lt;/p&gt;
&lt;p&gt;При этом akka имеет грамотный подход – реализации работы различных механизмов по сети ставиться во главу угла, а локальная работа рассматривается, как один из способов оптимизации.&lt;/p&gt;
&lt;h3&gt;remote vs cluster&lt;/h3&gt;
&lt;p&gt;В akka есть понятие "&lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/remoting.html"&gt;akka remote&lt;/a&gt;" – это возможность работать с любыми акторами прозрачно, не зная, где именно они находятся - локально или удалённо. Вы должны каким-либо образом знать, как до этих акторов добраться и эта реализация на вашей ответственности.&lt;/p&gt;
&lt;p&gt;Поверх akka remote строиться &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html"&gt;akka cluster&lt;/a&gt;, который реализует кластерное решение, т.е. количество нод может динамически меняться, каждой ноде может быть назначена роль, которую она исполняет в системе.&lt;/p&gt;
&lt;p&gt;Ноды договариваются с друг другом по &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#Gossip"&gt;gossip протоколу&lt;/a&gt; и внутри используют для хранения состояния CRDT структуры. Одна из нод назначается мастером, если она погасла мастером станет автоматически другая нода.&lt;/p&gt;
&lt;p&gt;Гашение нод вы определяете сами, система только говорит, что нода стала не доступна, вы сами можете решить, что делать - удалять её из кластера или нет. Есть стандартная реализация, когда нода удаляется после недоступности в течении какого-то времени.&lt;/p&gt;
&lt;p&gt;На события кластера, или более точно на жизненный цикл его нод, &lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/cluster-usage.html#A_Simple_Cluster_Example"&gt;можно подписаться&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Некоторые вещи в akka cluster ещё только в &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#niy"&gt;планах на реализацию&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Нет встроенного механизма сказать кластеру "я запустился", у ноды при старте должен быть список seed нод, хотя бы одна из которых должна работать. Seed нодой может быть любая нода работающего кластера. Т.е. в реальной жизни тут нужно будет брать какие-то решения для discovery. Как вариант предлагают также держать ноды, которые ничего не делают (не запускают пользовательские акторы), а только используются как seed ноды.&lt;/p&gt;
&lt;p&gt;Пока всё. Некоторые из аспектов описанных выше я буду изучать подробнее и ещё про них напишу. Если найдёте в моих записях ошибки, буду раз замечаниям.&lt;/p&gt;</content><category term="akka"></category></entry><entry><title>Отличие Future от Promise</title><link href="https://blog.maizy.ru/posts/future-vs-promise" rel="alternate"></link><published>2015-04-13T00:00:00+03:00</published><updated>2015-04-13T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-04-13:/posts/future-vs-promise</id><summary type="html">&lt;p&gt;Недавно пытался на пальцах объяснить отличие Future от Promise. Понятия эти очень близкие, даже &lt;a href="http://en.wikipedia.org/wiki/Futures_and_promises"&gt;статья на Wikipedia&lt;/a&gt; про них одна.&lt;/p&gt;
&lt;p&gt;Как правило Future и Promise используются как контейнер, для представления данных, которых пока нет, но уже можно сформировать цепочку их обработки. Реализации, которые мне известны: &lt;a href="https://twistedmatrix.com/documents/14.0.1/core/howto/defer.html"&gt;Deffered в Twisted&lt;/a&gt;, &lt;a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects"&gt;Future в python 3&lt;/a&gt;, его &lt;a href="http://www.tornadoweb.org/en/branch3.2/concurrent.html?highlight=future#tornado.concurrent.Future"&gt;примитивный backport в tornado&lt;/a&gt; и &lt;a href="https://api.jquery.com/category/deferred-object/"&gt;Deffered в jQuery&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Мне нравится такое определение разницы:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Future&lt;/strong&gt; – это контейнер, на результат которого вы &lt;em&gt;подписываетесь&lt;/em&gt;, но не управляете его появлением.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt; – это контейнер, результат в который вы &lt;em&gt;предоставляете&lt;/em&gt; и сами управляете его появлением в будущем.&lt;/p&gt;
&lt;p&gt;Условно можно считать Future "переменной", а Promise "функцией по установке переменной". Логично, что во многих реализациях эти объекты порождаются парами. Иногда даже эти понятия смешивают в один контейнер, который предоставляет реализации обоих задач, например, так сделано в jQuery и python. Но даже, если реализация смешана, полезно каким-либо образом, хотя бы в соглашениях понимать имеете ли вы право "зажечь" контейнер или имеете право только подписываться на него.&lt;/p&gt;
&lt;p&gt;За Future не нужно следить и можно считать, что код который их вернул обязательно когда-нибудь вызовет ваши callback'и. За Promise же вы ответственны и должны не забыть вызвать его в любом случае, даже если ваш код упал с какой-то ожидаемой или не ожидаемой ошибкой.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Недавно пытался на пальцах объяснить отличие Future от Promise. Понятия эти очень близкие, даже &lt;a href="http://en.wikipedia.org/wiki/Futures_and_promises"&gt;статья на Wikipedia&lt;/a&gt; про них одна.&lt;/p&gt;
&lt;p&gt;Как правило Future и Promise используются как контейнер, для представления данных, которых пока нет, но уже можно сформировать цепочку их обработки. Реализации, которые мне известны: &lt;a href="https://twistedmatrix.com/documents/14.0.1/core/howto/defer.html"&gt;Deffered в Twisted&lt;/a&gt;, &lt;a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects"&gt;Future в python 3&lt;/a&gt;, его &lt;a href="http://www.tornadoweb.org/en/branch3.2/concurrent.html?highlight=future#tornado.concurrent.Future"&gt;примитивный backport в tornado&lt;/a&gt; и &lt;a href="https://api.jquery.com/category/deferred-object/"&gt;Deffered в jQuery&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Мне нравится такое определение разницы:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Future&lt;/strong&gt; – это контейнер, на результат которого вы &lt;em&gt;подписываетесь&lt;/em&gt;, но не управляете его появлением.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt; – это контейнер, результат в который вы &lt;em&gt;предоставляете&lt;/em&gt; и сами управляете его появлением в будущем.&lt;/p&gt;
&lt;p&gt;Условно можно считать Future "переменной", а Promise "функцией по установке переменной". Логично, что во многих реализациях эти объекты порождаются парами. Иногда даже эти понятия смешивают в один контейнер, который предоставляет реализации обоих задач, например, так сделано в jQuery и python. Но даже, если реализация смешана, полезно каким-либо образом, хотя бы в соглашениях понимать имеете ли вы право "зажечь" контейнер или имеете право только подписываться на него.&lt;/p&gt;
&lt;p&gt;За Future не нужно следить и можно считать, что код который их вернул обязательно когда-нибудь вызовет ваши callback'и. За Promise же вы ответственны и должны не забыть вызвать его в любом случае, даже если ваш код упал с какой-то ожидаемой или не ожидаемой ошибкой.&lt;/p&gt;</content><category term="async"></category></entry><entry><title>Использование ansible в Docker контейнерах</title><link href="https://blog.maizy.ru/posts/ansible-in-docker" rel="alternate"></link><published>2015-04-02T00:00:00+03:00</published><updated>2015-04-02T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-04-02:/posts/ansible-in-docker</id><summary type="html">&lt;p&gt;Для решения задачи настройки сервера уже давно придумали много вещей лучше, чем просто bash скрипт. Я в частности, использую &lt;a href="http://docs.ansible.com/index.html"&gt;ansible&lt;/a&gt;. Но для создания docker контейнеров &lt;a href="https://docs.docker.com/reference/builder/"&gt;по прежнему предлагается&lt;/a&gt; механизм который не далеко ушёл от bash скриптов.&lt;/p&gt;
&lt;p&gt;Мне понадобилось строить на сервере набор контейнеров, причём полностью автоматизировано. Если создание docker images на основе Dockerfile и работа с готовыми контейнерами в ansible решается из коробки, то с настройкой контейнеров через ansible пришлось немного извратиться.&lt;/p&gt;
&lt;p&gt;Идея простая:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;сделать базовый image в docker в котором через Dockerfile устанавливается только ansible,&lt;/li&gt;
&lt;li&gt;засинхронизировать с локальной машины на хост машину все файлы, нужные для ansible - роли, настройки и таски,&lt;/li&gt;
&lt;li&gt;создать контейнер,&lt;/li&gt;
&lt;li&gt;засинхронизированные настройки подключить в volume внутри контейнера,&lt;/li&gt;
&lt;li&gt;запустить ansible-playbook через docker exec,&lt;/li&gt;
&lt;li&gt;готовые контейнеры при необходимости коммитяться и используются как основа для других контейнеров.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Плюсы ansible здесь – идемпотентность, готовые модули и возможность использовать некоторые роли, как для хост машин, так и для контейнеров. Например, у меня есть абстрактная роль &lt;code&gt;nginx&lt;/code&gt; и отдельная роль поверх неё &lt;code&gt;nginx_container&lt;/code&gt; со спецификой для контейнеров.&lt;/p&gt;
&lt;p&gt;То что получилось и подробности работы можно посмотреть в &lt;a href="https://github.com/scala-moscow/deploy"&gt;репозитории scala-moscow/deploy&lt;/a&gt;.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Для решения задачи настройки сервера уже давно придумали много вещей лучше, чем просто bash скрипт. Я в частности, использую &lt;a href="http://docs.ansible.com/index.html"&gt;ansible&lt;/a&gt;. Но для создания docker контейнеров &lt;a href="https://docs.docker.com/reference/builder/"&gt;по прежнему предлагается&lt;/a&gt; механизм который не далеко ушёл от bash скриптов.&lt;/p&gt;
&lt;p&gt;Мне понадобилось строить на сервере набор контейнеров, причём полностью автоматизировано. Если создание docker images на основе Dockerfile и работа с готовыми контейнерами в ansible решается из коробки, то с настройкой контейнеров через ansible пришлось немного извратиться.&lt;/p&gt;
&lt;p&gt;Идея простая:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;сделать базовый image в docker в котором через Dockerfile устанавливается только ansible,&lt;/li&gt;
&lt;li&gt;засинхронизировать с локальной машины на хост машину все файлы, нужные для ansible - роли, настройки и таски,&lt;/li&gt;
&lt;li&gt;создать контейнер,&lt;/li&gt;
&lt;li&gt;засинхронизированные настройки подключить в volume внутри контейнера,&lt;/li&gt;
&lt;li&gt;запустить ansible-playbook через docker exec,&lt;/li&gt;
&lt;li&gt;готовые контейнеры при необходимости коммитяться и используются как основа для других контейнеров.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Плюсы ansible здесь – идемпотентность, готовые модули и возможность использовать некоторые роли, как для хост машин, так и для контейнеров. Например, у меня есть абстрактная роль &lt;code&gt;nginx&lt;/code&gt; и отдельная роль поверх неё &lt;code&gt;nginx_container&lt;/code&gt; со спецификой для контейнеров.&lt;/p&gt;
&lt;p&gt;То что получилось и подробности работы можно посмотреть в &lt;a href="https://github.com/scala-moscow/deploy"&gt;репозитории scala-moscow/deploy&lt;/a&gt;.&lt;/p&gt;</content><category term="ansible"></category><category term="docker"></category></entry><entry><title>Почему я завёл этот блог.</title><link href="https://blog.maizy.ru/posts/why" rel="alternate"></link><published>2015-04-02T00:00:00+03:00</published><updated>2015-04-02T00:00:00+03:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2015-04-02:/posts/why</id><summary type="html">&lt;p&gt;Фанаты GTD негодуют, но у меня пока не нашлось времени написать этот пост.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Фанаты GTD негодуют, но у меня пока не нашлось времени написать этот пост.&lt;/p&gt;</content></entry><entry><title>Питон в коробке – venv в python 3.3</title><link href="https://blog.maizy.ru/posts/python3-3-venv" rel="alternate"></link><published>2012-10-02T00:00:00+04:00</published><updated>2012-10-02T00:00:00+04:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2012-10-02:/posts/python3-3-venv</id><summary type="html">&lt;p&gt;Наверняка, большинство из тех, кто разрабатывает или деплоит Python приложения, использует виртуальные окружения. В частности через &lt;a href="http://www.virtualenv.org/en/latest/"&gt;virtualenv&lt;/a&gt;, написанный Ian Bicking.&lt;/p&gt;
&lt;p&gt;Идея оказалась так хороша и распространена, что нечто похожее теперь присутствует в Python 3.3 из коробки в виде модуля venv. Он почти такой же, как virtualenv, только немного лучше.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="http://habrahabr.ru/post/157287/"&gt;Полная версия поста на Хабрахабр&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Наверняка, большинство из тех, кто разрабатывает или деплоит Python приложения, использует виртуальные окружения. В частности через &lt;a href="http://www.virtualenv.org/en/latest/"&gt;virtualenv&lt;/a&gt;, написанный Ian Bicking.&lt;/p&gt;
&lt;p&gt;Идея оказалась так хороша и распространена, что нечто похожее теперь присутствует в Python 3.3 из коробки в виде модуля venv. Он почти такой же, как virtualenv, только немного лучше.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="http://habrahabr.ru/post/157287/"&gt;Полная версия поста на Хабрахабр&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</content><category term="python"></category><category term="habrahabr"></category></entry><entry><title>Ваш заказ -555 тазиков на сумму -55500 руб</title><link href="https://blog.maizy.ru/posts/taziki" rel="alternate"></link><published>2007-06-10T00:00:00+04:00</published><updated>2007-06-10T00:00:00+04:00</updated><author><name>Никита Ковалев</name></author><id>tag:blog.maizy.ru,2007-06-10:/posts/taziki</id><summary type="html">&lt;p&gt;&lt;em&gt;Забавный пост написанный на Хабре в 2007 году. В 2007, Карл!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Речь идёт о распространённой ошибке в интернет-магазинах. В offline-магазине для выбора 555-и синих пластиковых тазика вам придётся: положить в корзину все 14 штук с витрины, залезть на верхнюю полку стеллажа и достать ещё 43, а за остальными идти с продавцом на склад и найти там ещё лишь 143 штуки.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="http://habrahabr.ru/post/10491/"&gt;Полная версия поста на Хабрахабр&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;Забавный пост написанный на Хабре в 2007 году. В 2007, Карл!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Речь идёт о распространённой ошибке в интернет-магазинах. В offline-магазине для выбора 555-и синих пластиковых тазика вам придётся: положить в корзину все 14 штук с витрины, залезть на верхнюю полку стеллажа и достать ещё 43, а за остальными идти с продавцом на склад и найти там ещё лишь 143 штуки.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="http://habrahabr.ru/post/10491/"&gt;Полная версия поста на Хабрахабр&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</content><category term="python"></category><category term="habrahabr"></category></entry></feed>