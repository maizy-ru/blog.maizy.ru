<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>blog.maizy.ru</title><link>http://blog.maizy.ru/</link><description></description><atom:link href="http://blog.maizy.ru.local/feeds/nikita-kovalev.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 17 Aug 2015 00:00:00 +0300</lastBuildDate><item><title>FPConf 2015 - заметки на полях</title><link>http://blog.maizy.ru/posts/fpconf-2015</link><description>&lt;p&gt;Побывал на конференции &lt;a href="http://fpconf.ru/"&gt;FPConf&lt;/a&gt;. Поделюсь своими мыслями, возникшими при прослушивании докладов. Я в основном сидел на втором потоке, где было про scala, UI и пр. Первый поток был преимущественно про Erlang и Haskell.&lt;/p&gt;
&lt;p&gt;Организаторы обещали, что будет видео, надеюсь пополнить эту статью ссылкам в будущем.&lt;/p&gt;
&lt;h3&gt;Cамурайский путь молодого scala-программиста, Сергей Лобин, Sputnik.ru&lt;/h3&gt;
&lt;p&gt;В докладе было мало про scala, больше про проблемы при разработки геокодера в Спутнике. Главный печальный для всех фанатов Scala вывод – Scala в production и них не прижилась, найти разработчиков сложно, Go разработчиков найти значительно проще.&lt;/p&gt;
&lt;h3&gt;Макросы scala, Михаил Муцянко, JetBrains&lt;/h3&gt;
&lt;p&gt;Хороший вводный доклад про макросы Scala от разработчика &lt;a href="http://blog.jetbrains.com/scala/"&gt;Scala plugin в IDEA&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Из запомнившегося:&lt;/p&gt;
&lt;p&gt;Удобный способ построения AST в макросе через &lt;a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html"&gt;Q интерполятор&lt;/a&gt; (квазикватирование).&lt;/p&gt;
&lt;p&gt;Килер фича, когда Михаил нажатием одной волшебной кнопки прямо в IDEA, показал как разворачивается макрос в Scala код. К сожалению оказалось, что это не из production версии плагина и вроде ожидать такое в ближайшее время не стоит, так как работает не всегда корректно. Очень вкусная возможность, будем ждать.&lt;/p&gt;
&lt;p&gt;В 2.12 ожидается значительное улучшение в деле разработки макросов за счёт нового проекта &lt;a href="http://scalameta.org/"&gt;ScalaMeta&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Хорошая ссылка на изучение: What Are Macros Good For? от Евгения Бурмако &lt;a href="http://www.youtube.com/watch?v=4Rxo_7lrb7Y"&gt;YouTube&lt;/a&gt;, &lt;a href="http://scalamacros.org/paperstalks/2013-07-17-WhatAreMacrosGoodFor.pdf"&gt;слайды&lt;/a&gt;. BTW про самого Евгения и его работу над Scala макросами можно узнать в &lt;a href="http://eax.me/eaxcast-s02e10/"&gt;EaxCast S02E10&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Доклад рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;Встраивание языка в строковой интерполятор, Михаил Лиманский, ЭСК&lt;/h3&gt;
&lt;p&gt;Хороший практический доклад, как вместо DSL порой можно обойтись интерполятором. Какие возможности, плюсы и минусы такого подхода. Можно прямо брать доклад и писать свой интерполятор как по tutorial'у.&lt;/p&gt;
&lt;p&gt;В качестве домашнего задания для себя запомнил задачу реализовать интерполятор для типобезопасного форматирования строки. Хотим с &lt;a href="http://habrahabr.ru/users/aveic/"&gt;aveic&lt;/a&gt; попробовать независимо друг от друга реализовать это и посмотреть, что получиться.&lt;/p&gt;
&lt;p&gt;Рекомендую для тех, кто интересуется темой.&lt;/p&gt;
&lt;h3&gt;Lenses And Prisms, Эдвард Кметт&lt;/h3&gt;
&lt;p&gt;Самый звёздный докладчик на конференции. К сожалению без знания хотя бы основ синтаксиса Haskell понять что-то было сложно. Докладчик проводил доклад в потрясающей форме - выдавая как из пулемёта кучу кода на Haskell прями в vim'е.&lt;/p&gt;
&lt;p&gt;Чтобы понять что к чему, я смотрел на порт этой библиотеки на Scala - &lt;a href="https://github.com/julien-truffaut/Monocle"&gt;Monocle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В общих словах – это удобный способ изменения иммутабельных структур с возможностью написания максимально абстрактных маленьких кусочков с дальнейшим комбинированием в более сложные кусочки.&lt;/p&gt;
&lt;h3&gt;Реактивные потоки в backend-е, Алексей Романчук, 2ГИС&lt;/h3&gt;
&lt;p&gt;Хорошая success story про использование akka streams в production. Для меня теперь это один из ответов на вопрос «где нам нужна akka?».&lt;/p&gt;
&lt;p&gt;Забавные слайды с цветными "сосиками".&lt;/p&gt;
&lt;p&gt;Прозвучавшее число потерь на akka streams по сравнению с голыми акторами ~10%.&lt;/p&gt;
&lt;p&gt;Рекомендую всем, кому интересны akka streams.&lt;/p&gt;
&lt;h3&gt;Scala performance для сомневающихся, Роман Гребенников, Sociohub.ru&lt;/h3&gt;
&lt;p&gt;Самый запомнившийся доклад. Покрывает сразу две темы - пару примеров того как все модные молодёжные FP штуки из scala отражаются в bytecode JVM и машинном коде, какие потери они за собой несут или не несут. А также способы самому развернуть, померить и понять как выполняется тот или иной код.&lt;/p&gt;
&lt;p&gt;Вкратце про проблемы – простой pattern matching по типу параметра - также быстро как колбаса из if'ов. Есть проблемы с boxing/unboxing в Scala collection и прикладывать &lt;a href="http://www.scala-lang.org/api/2.11.4/index.html#scala.specialized"&gt;@specialized&lt;/a&gt; не поможет.&lt;/p&gt;
&lt;p&gt;Рекомендую к просмотру.&lt;/p&gt;
&lt;h3&gt;В общем&lt;/h3&gt;
&lt;p&gt;Очень приятное послевкусие от конференции, не ожидал, что про FP будет так целостно. Как сказали организаторы было 180 человек.&lt;/p&gt;
&lt;p&gt;Не посмотрел в живую «Фронтэнд без грусти» Никиты Прокопова, о котором наслышан от коллег, которые видели доклад на какой-то другой конференции. А также хочется поглядеть на «Aрхитектура UI на основе функциональных линз» от Ильи Беда.&lt;/p&gt;
&lt;p&gt;Буду ждать видео.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Mon, 17 Aug 2015 00:00:00 +0300</pubDate><guid>tag:blog.maizy.ru,2015-08-17:posts/fpconf-2015</guid><category>conference</category><category>scala</category></item><item><title>Akka graceful shutdown и обработка системных сигналов</title><link>http://blog.maizy.ru/posts/akka-graceful-shutdown</link><description>&lt;p&gt;Когда начал писать для себя &lt;a href="https://github.com/maizy/akka-cluster-heartbeat"&gt;hello world на akka&lt;/a&gt; сразу захотелось сделать какой-то артефакт, удобный для жизни в дикой среде production. Хочется, чтобы приложение вело себя как примерный гражданин, умело правильно реагировать на всякие системные сигналы и прочее.&lt;/p&gt;
&lt;p&gt;С упаковкой приложения в jar вместе с scala runtime удалось легко разобраться. Помогут &lt;code&gt;sbt-native-packager&lt;/code&gt; и &lt;code&gt;sbt-assembly&lt;/code&gt;. Напишу про это позже, когда ещё пойму как правильно результат сложить в .deb пакет.&lt;/p&gt;
&lt;p&gt;Не сразу почему-то удалось сделать правильные реагирования на сигналы системы. Меня пока не интересуют всякие специфичные штуки, достаточно было двух сигналов выключения - SIGINT и SIGTERM, по которым хотелось аккуратно потушить ноду в akka cluster - убить её локальные акторы, отсоединиться и пр.&lt;/p&gt;
&lt;p&gt;Сначала попробовал использовать модный_молодёжный метод &lt;a href="http://www.scala-lang.org/api/current/index.html#scala.sys.package@addShutdownHook(body:=&amp;gt;Unit):scala.sys.ShutdownHookThread"&gt;scala.sys.addShutdownHook&lt;/a&gt;. Он принимает &lt;code&gt;=&amp;gt; Unit&lt;/code&gt; и выполняет его в отдельном треде, когда завершается jvm. Вызов не гарантируется, что в данном случае ок. Плюс метода - переносимость. Минус - код возврата не возможно поставить, метод &lt;code&gt;System.exit()&lt;/code&gt; выполняется, но код не ставиться. Экспериментально понял, что на SIGINT код всегда 130, на SIGTERM - 146. Вторая проблема - akka при выключении часть логов пишет в stdout, которые при использовании хука уже не выводятся. Не проверял, но кажется stdout закрывается раньше, чем вызывается этот хук.&lt;/p&gt;
&lt;p&gt;Пришлось взять в руки обработчик сигналов и делать на нём. Он из пакета &lt;code&gt;sun.misc&lt;/code&gt;, так что с альтернативными jvm могут быть вопросы, но меня это не волнует в данный момент.&lt;/p&gt;
&lt;p&gt;В итоге метод выглядит примерно так:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.util.concurrent.atomic.AtomicBoolean&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sun.misc.SignalHandler&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sun.misc.Signal&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.concurrent.duration._&lt;/span&gt;

&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.typesafe.config.ConfigFactory&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.cluster.Cluster&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.actor.ActorSystem&lt;/span&gt;
&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;akka.util.Timeout&lt;/span&gt;

&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Main&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;SignalHandler&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;SIGING&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;INT&amp;quot;&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;SIGTERM&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;TERM&amp;quot;&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;terminated&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AtomicBoolean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;// регистрируем сам App объект, как обработчик сигналов&lt;/span&gt;
  &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGING&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGTERM&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;ConfigFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;ActorSystem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;main&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;executionContext&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dispatcher&lt;/span&gt;
  &lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;defaultTimeout&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Timeout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;500.&lt;/span&gt;&lt;span class="n"&gt;millis&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;cluster&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Cluster&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;//hook для akka, будет использоваться для любых остановок, не только по сигналам&lt;/span&gt;
  &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;registerOnTermination&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="nc"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// собственно обработчик&lt;/span&gt;
  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Signal&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;terminated&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compareAndSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;SIGING&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;SIGTERM&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shutdown&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Теперь и сигналы честно обрабатываются, и коды возвратов правильные, и все выходы из приложения сводятся в хук для akka.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Thu, 06 Aug 2015 00:00:00 +0300</pubDate><guid>tag:blog.maizy.ru,2015-08-06:posts/akka-graceful-shutdown</guid><category>akka</category><category>devops</category></item><item><title>Akka для распределённых приложений - remote vs cluster</title><link>http://blog.maizy.ru/posts/akka-remote-n-cluster</link><description>&lt;p&gt;Буду делать небольшие заметки на полях по результатам изучения akka.&lt;/p&gt;
&lt;p&gt;Akka – это система акторов на jvm, реализованная на scala. Можно использовать и из java. Про саму концепцию акторов можно почитать в &lt;a href="https://ru.wikipedia.org/wiki/Модель_акторов"&gt;интернетах&lt;/a&gt;, здесь я буду останавливаться на особенностях akka.&lt;/p&gt;
&lt;h3&gt;Что читать?&lt;/h3&gt;
&lt;p&gt;Я пока рекомендую такие источники:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://akka.io/docs/"&gt;официальная документация&lt;/a&gt; - она хорошая, содержит как теоретические основы, так и конкретные примеры кода и описания API. Можно читать из начала в конец, как книгу. Есть &lt;a href="http://doc.akka.io/docs/akka/2.3.12/AkkaScala.pdf"&gt;pdf&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;"Akka in Action" by Raymond Roestenburg, Rob Bakker, and Rob Williams - неплохая книга. Я читаю 16 MEAP (early access), к осени-зиме 2015 обещают релиз. &lt;a href="http://www.manning.com/roestenburg/"&gt;Цена 40$&lt;/a&gt;. В основном ориентируюсь на документацию, но в книге  плюс - итеративный подход к реализации демо проекта. Начинают с hello world'ов и далее по нарастающей. Было полезно, когда хотелось быстрого старта без изучения всех тонкостей теории.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stack Overflow - как всегда стоит делать аккуратно. Фреймворк активно развивается, некоторые вещи появляются, которые раньше нужно было самому велосипедить, некоторые становятся deprecated и пр., но есть не мало полезных объяснений.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Googling по тонким вопросам и непоняткам, который нередко приводит в google группу akka.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Если жалко 40$, то книгу можно не покупать. Благородя Typesafe хайпа в сети по akka хватает. Для фреймворка – это хорошо.&lt;/p&gt;
&lt;h3&gt;Применимость&lt;/h3&gt;
&lt;p&gt;Меня akka интересует в основном с точки зрения распределённых систем.
Однако akka работает и на одной jvm. Даже есть &lt;a href="http://engineering.intenthq.com/2015/06/wikidata-akka-streams/"&gt;успешные кейсы&lt;/a&gt;, когда в такой подход даёт выигрыш в противовес обычным многопоточным потокам.&lt;/p&gt;
&lt;p&gt;При этом akka имеет грамотный подход – реализации работы различных механизмов по сети ставиться во главу угла, а локальная работа рассматривается, как один из способов оптимизации.&lt;/p&gt;
&lt;h3&gt;remote vs cluster&lt;/h3&gt;
&lt;p&gt;В akka есть понятие "&lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/remoting.html"&gt;akka remote&lt;/a&gt;" – это возможность работать с любыми акторами прозрачно, не зная, где именно они находятся - локально или удалённо. Вы должны каким-либо образом знать, как до этих акторов добраться и эта реализация на вашей ответственности.&lt;/p&gt;
&lt;p&gt;Поверх akka remote строиться &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html"&gt;akka cluster&lt;/a&gt;, который реализует кластерное решение, т.е. количество нод может динамически меняться, каждой ноде может быть назначена роль, которую она исполняет в системе.&lt;/p&gt;
&lt;p&gt;Ноды договариваются с друг другом по &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#Gossip"&gt;gossip протоколу&lt;/a&gt; и внутри используют для хранения состояния CRDT структуры. Одна из нод назначается мастером, если она погасла мастером станет автоматически другая нода.&lt;/p&gt;
&lt;p&gt;Гашение нод вы определяете сами, система только говорит, что нода стала не доступна, вы сами можете решить, что делать - удалять её из кластера или нет. Есть стандартная реализация, когда нода удаляется после недоступности в течении какого-то времени.&lt;/p&gt;
&lt;p&gt;На события кластера, или более точно на жизненный цикл его нод, &lt;a href="http://doc.akka.io/docs/akka/2.3.12/scala/cluster-usage.html#A_Simple_Cluster_Example"&gt;можно подписаться&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Некоторые вещи в akka cluster ещё только в &lt;a href="http://doc.akka.io/docs/akka/2.3.12/common/cluster.html#niy"&gt;планах на реализацию&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Нет встроенного механизма сказать кластеру "я запустился", у ноды при старте должен быть список seed нод, хотя бы одна из которых должна работать. Seed нодой может быть любая нода работающего кластера. Т.е. в реальной жизни тут нужно будет брать какие-то решения для discovery. Как вариант предлагают также держать ноды, которые ничего не делают (не запускают пользовательские акторы), а только используются как seed ноды.&lt;/p&gt;
&lt;p&gt;Пока всё. Некоторые из аспектов описанных выше я буду изучать подробнее и ещё про них напишу. Если найдёте в моих записях ошибки, буду раз замечаниям.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Mon, 20 Jul 2015 00:00:00 +0300</pubDate><guid>tag:blog.maizy.ru,2015-07-20:posts/akka-remote-n-cluster</guid><category>akka</category></item><item><title>Отличие Future от Promise</title><link>http://blog.maizy.ru/posts/future-vs-promise</link><description>&lt;p&gt;Недавно пытался на пальцах объяснить отличие Future от Promise. Понятия эти очень близкие, даже &lt;a href="http://en.wikipedia.org/wiki/Futures_and_promises"&gt;статья на Wikipedia&lt;/a&gt; про них одна.&lt;/p&gt;
&lt;p&gt;Как правило Future и Promise используются как контейнер, для представления данных, которых пока нет, но уже можно сформировать цепочку их обработки. Реализации, которые мне известны: &lt;a href="https://twistedmatrix.com/documents/14.0.1/core/howto/defer.html"&gt;Deffered в Twisted&lt;/a&gt;, &lt;a href="https://docs.python.org/3/library/concurrent.futures.html#future-objects"&gt;Future в python 3&lt;/a&gt;, его &lt;a href="http://www.tornadoweb.org/en/branch3.2/concurrent.html?highlight=future#tornado.concurrent.Future"&gt;примитивный backport в tornado&lt;/a&gt; и &lt;a href="https://api.jquery.com/category/deferred-object/"&gt;Deffered в jQuery&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Мне нравится такое определение разницы:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Future&lt;/strong&gt; – это контейнер, на результат которого вы &lt;em&gt;подписываетесь&lt;/em&gt;, но не управляете его появлением.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Promise&lt;/strong&gt; – это контейнер, результат в который вы &lt;em&gt;предоставляете&lt;/em&gt; и сами управляете его появлением в будущем.&lt;/p&gt;
&lt;p&gt;Условно можно считать Future "переменной", а Promise "функцией по установке переменной". Логично, что во многих реализациях эти объекты порождаются парами. Иногда даже эти понятия смешивают в один контейнер, который предоставляет реализации обоих задач, например, так сделано в jQuery и python. Но даже, если реализация смешана, полезно каким-либо образом, хотя бы в соглашениях понимать имеете ли вы право "зажечь" контейнер или имеете право только подписываться на него.&lt;/p&gt;
&lt;p&gt;За Future не нужно следить и можно считать, что код который их вернул обязательно когда-нибудь вызовет ваши callback'и. За Promise же вы ответственны и должны не забыть вызвать его в любом случае, даже если ваш код упал с какой-то ожидаемой или не ожидаемой ошибкой.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Mon, 13 Apr 2015 00:00:00 +0300</pubDate><guid>tag:blog.maizy.ru,2015-04-13:posts/future-vs-promise</guid><category>async</category></item><item><title>Использование ansible в Docker контейнерах</title><link>http://blog.maizy.ru/posts/ansible-in-docker</link><description>&lt;p&gt;Для решения задачи настройки сервера уже давно придумали много вещей лучше, чем просто bash скрипт. Я в частности, использую &lt;a href="http://docs.ansible.com/index.html"&gt;ansible&lt;/a&gt;. Но для создания docker контейнеров &lt;a href="https://docs.docker.com/reference/builder/"&gt;по прежнему предлагается&lt;/a&gt; механизм который не далеко ушёл от bash скриптов.&lt;/p&gt;
&lt;p&gt;Мне понадобилось строить на сервере набор контейнеров, причём полностью автоматизировано. Если создание docker images на основе Dockerfile и работа с готовыми контейнерами в ansible решается из коробки, то с настройкой контейнеров через ansible пришлось немного извратиться.&lt;/p&gt;
&lt;p&gt;Идея простая:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;сделать базовый image в docker в котором через Dockerfile устанавливается только ansible,&lt;/li&gt;
&lt;li&gt;засинхронизировать с локальной машины на хост машину все файлы, нужные для ansible - роли, настройки и таски,&lt;/li&gt;
&lt;li&gt;создать контейнер,&lt;/li&gt;
&lt;li&gt;засинхронизированные настройки подключить в volume внутри контейнера,&lt;/li&gt;
&lt;li&gt;запустить ansible-playbook через docker exec,&lt;/li&gt;
&lt;li&gt;готовые контейнеры при необходимости коммитяться и используются как основа для других контейнеров.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Плюсы ansible здесь – идемпотентность, готовые модули и возможность использовать некоторые роли, как для хост машин, так и для контейнеров. Например, у меня есть абстрактная роль &lt;code&gt;nginx&lt;/code&gt; и отдельная роль поверх неё &lt;code&gt;nginx_container&lt;/code&gt; со спецификой для контейнеров.&lt;/p&gt;
&lt;p&gt;То что получилось и подробности работы можно посмотреть в &lt;a href="https://github.com/scala-moscow/deploy"&gt;репозитории scala-moscow/deploy&lt;/a&gt;.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Thu, 02 Apr 2015 00:00:00 +0300</pubDate><guid>tag:blog.maizy.ru,2015-04-02:posts/ansible-in-docker</guid><category>ansible</category><category>docker</category></item><item><title>Почему я завёл этот блог.</title><link>http://blog.maizy.ru/posts/why</link><description>&lt;p&gt;TODO: Текст, текст.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Thu, 02 Apr 2015 00:00:00 +0300</pubDate><guid>tag:blog.maizy.ru,2015-04-02:posts/why</guid></item><item><title>Питон в коробке – venv в python 3.3</title><link>http://blog.maizy.ru/posts/python3-3-venv</link><description>&lt;p&gt;Наверняка, большинство из тех, кто разрабатывает или деплоит Python приложения, использует виртуальные окружения. В частности через &lt;a href="http://www.virtualenv.org/en/latest/"&gt;virtualenv&lt;/a&gt;, написанный Ian Bicking.&lt;/p&gt;
&lt;p&gt;Идея оказалась так хороша и распространена, что нечто похожее теперь присутствует в Python 3.3 из коробки в виде модуля venv. Он почти такой же, как virtualenv, только немного лучше.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="http://habrahabr.ru/post/157287/"&gt;Полная версия поста на Хабрахабр&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Tue, 02 Oct 2012 00:00:00 +0400</pubDate><guid>tag:blog.maizy.ru,2012-10-02:posts/python3-3-venv</guid><category>python</category><category>habrahabr</category></item><item><title>Ваш заказ -555 тазиков на сумму -55500 руб</title><link>http://blog.maizy.ru/posts/taziki</link><description>&lt;p&gt;&lt;em&gt;Забавный пост написанный на Хабре в 2007 году. В 2007, Карл!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Речь идёт о распространённой ошибке в интернет-магазинах. В offline-магазине для выбора 555-и синих пластиковых тазика вам придётся: положить в корзину все 14 штук с витрины, залезть на верхнюю полку стеллажа и достать ещё 43, а за остальными идти с продавцом на склад и найти там ещё лишь 143 штуки.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href="http://habrahabr.ru/post/10491/"&gt;Полная версия поста на Хабрахабр&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Никита Ковалев</dc:creator><pubDate>Sun, 10 Jun 2007 00:00:00 +0400</pubDate><guid>tag:blog.maizy.ru,2007-06-10:posts/taziki</guid><category>python</category><category>habrahabr</category></item></channel></rss>