<!DOCTYPE html>
<html lang="ru"
>
<head>
    <title>scala - blog.maizy.ru</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">




    <meta name="author" content="Никита Ковалев" />
    <meta name="keywords" content="scala" />

    <!-- Open Graph tags -->
        <meta property="og:site_name" content="blog.maizy.ru" />
        <meta property="og:type" content="website"/>
        <meta property="og:title" content="blog.maizy.ru"/>
        <meta property="og:url" content="https://blog.maizy.ru"/>
        <meta property="og:description" content="blog.maizy.ru"/>


    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://blog.maizy.ru/theme/css/bootstrap.yeti.min.css" type="text/css"/>
    <link href="https://blog.maizy.ru/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://blog.maizy.ru/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="https://blog.maizy.ru/theme/css/style.css" type="text/css"/>
        <link href="https://blog.maizy.ru/static/css/custom.css" rel="stylesheet">

        <link href="https://blog.maizy.ru/feeds/category/tech/atom.xml" type="application/atom+xml" rel="alternate"
              title="blog.maizy.ru"/>
        <link href="https://blog.maizy.ru/feeds/category/tech/rss.xml" type="application/rss+xml" rel="alternate"
              title="blog.maizy.ru"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://blog.maizy.ru/" class="navbar-brand">
blog.maizy.ru            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li >
                            <a href="https://blog.maizy.ru/life">Life</a>
                        </li>
                        <li >
                            <a href="https://blog.maizy.ru/">Tech</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://blog.maizy.ru/archives"><i class="fa fa-th-list"></i><span class="icon-label">Архив</span></a></li>
              <li><a href="https://blog.maizy.ru/feeds/category/tech/rss.xml"><i class="fa fa-rss"></i><span class="icon-label">RSS</span></a></li>
              <li><a href="https://blog.maizy.ru/about"><i class="fa fa-bed"></i><span class="icon-label">О блоге</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-xs-12 col-sm-12 col-md-offset-1 col-md-10 col-lg-8 col-lg-offset-2">

            <article>
                <h2><a href="https://blog.maizy.ru/posts/scala-cats-summary">Конспект по Scala with Cats</a></h2>
                    <div class="article-info">
<footer class="post-info">
    <div class="published">
        <time datetime="2018-12-21T00:00:00+03:00"> 21.12.2018</time>
    </div>



<div class="tags">
<i class="fa fa-tags"></i>&nbsp;
	<a href="https://blog.maizy.ru/tag/cats">cats</a>
        /
	<a href="https://blog.maizy.ru/tag/scala">scala</a>
</div>

</footer><!-- /.post-info -->                    </div>
                <div class="summary"><p>Scala with Cats – это <a href="https://underscore.io/books/scala-with-cats/">свободно доступная книга</a>, написанная Noel Welsh и Dave Gurnell из Underscore. Охватывает все основы использования библиотеки <a href="https://typelevel.org/cats/">cats</a>.</p>
<p>Книгу рекомендую читать с выполнением заданий, без этого лично мне полного понимания достичь не удалось.</p>
<p>Ниже краткий насколько возможно конспект по Type Class'ам из книги.</p>
<h3>Show</h3>
<ul>
<li>вывести на печать любой тип</li>
<li>syntax: <code>.show</code></li>
</ul>
<h3>Eq</h3>
<ul>
<li>типобезопасное сравнение</li>
<li>syntax:<ul>
<li><code>a === b</code></li>
<li><code>a =!= b</code></li>
</ul>
</li>
</ul>
<h3>Monoid</h3>
<ul>
<li>операции<ul>
<li><code>.combine(a1, a2)</code></li>
<li><code>.empty[A]</code></li>
</ul>
</li>
<li>законы:<ul>
<li>combine ассоциативный</li>
<li>empty должен быть нейтральным элементом (identity element)</li>
</ul>
</li>
</ul>
<h3>Semigroup</h3>
<ul>
<li>объединение двух значений</li>
<li>только combine из Monoid</li>
<li>там где требуется Semigroup, всегда можно использовать Monoid</li>
<li>нужен так как не всегда существует нейтральный элемент, пример – NonEmptyList</li>
<li>syntax: <code>a |+| b</code></li>
</ul>
<h3>Functor</h3>
<ul>
<li>что-то у чего есть <code>map</code></li>
<li>не стоит думать об этом только, как о проходе по списку, это может быть и работа с внутренним состоянием "контейнера" (в контексте этого "контейнера"), без извлечения значения из "контейнера".</li>
<li>операции:<ul>
<li><code>.lift(f)</code></li>
</ul>
</li>
<li>syntax:<ul>
<li><code>f.map(g)</code></li>
</ul>
</li>
</ul>
<h3>Contravariant (Functor)</h3>
<ul>
<li>из <code>F[B]</code> имея <code>A =&gt; B</code> получить <code>F[A]</code></li>
<li>syntax: <code>.contramap(f)</code></li>
</ul>
<h3>Invariant</h3>
<ul>
<li>имея <code>A =&gt; B</code>, <code>B =&gt; A</code> и <code>Monoid[B]</code> получить <code>Monoid[A]</code></li>
<li>syntax: <code>Monoid[B].imap(f)(g)</code></li>
</ul>
<h3>Monad</h3>
<ul>
<li>1000 разных подходов к определению, в книге такое: монада – механизм для последовательных вычислений</li>
<li>операции<ul>
<li><code>.pure(a)</code> – создание монадического контекста из сырого значения</li>
<li><code>.flatMap(f)</code> – извлечение значения из контекста и создание следующего контекста в последовательности</li>
</ul>
</li>
<li>любая монада – функтор, map легко построить из pure+flatMap</li>
<li>laws:<ul>
<li>левоассоциативность: <code>pure(a).flatMap(f) == f(a)</code>. тут важно помнить об эффектах. именно по этой причине Try не Monad, так как если "снять" с него контекст монады при обычном вызове получим эффект – исключение, а если не снять то получим Failure.</li>
<li>правоассоциативность: <code>m.flatMap(pure) == m</code>.</li>
<li>ассоциативность: <code>m.flatMap(f).flatMap(g) == m.flatMap(x =&gt; f(x).flatMap(g))</code></li>
</ul>
</li>
<li>syntax:<ul>
<li><code>.pure[T]</code> (из cats.syntax.applicative)</li>
<li><code>.map(f)</code> (из cats.syntax.functor)</li>
<li><code>.flatMap(f)</code> (из cats.syntax.flatMap)</li>
<li>можно использовать for comprehensions из scala</li>
</ul>
</li>
<li>при определении своих монад<ul>
<li><code>.flatMap</code></li>
<li><code>.pure</code></li>
<li><code>.tailRecM</code> – оптимизация для вложенных .flatMap вызовов. метод можно делать <code>@tailrec</code></li>
</ul>
</li>
</ul>
<h3>Id</h3>
<ul>
<li>Identity Monad</li>
<li>позволяет использовать в коде, где ожидаются монады немонадные значения</li>
<li>мощный инструмент для тестов кода построенного на монадах</li>
<li>например<ul>
<li><code>123 : Id[Int]</code></li>
<li><code>"abc" : Id[String]</code></li>
</ul>
</li>
</ul>
<h3>Either</h3>
<ul>
<li>обычный тип из scala</li>
<li>операции:<ul>
<li><code>.orElse(Either)</code></li>
<li><code>.ensure(e)(predicate)</code></li>
<li><code>.recover(partialFunction)</code></li>
<li><code>.recoverWith(partialFunction)</code></li>
<li><code>.leftMap(f)</code></li>
<li><code>.bimap(f, g)</code></li>
<li><code>.swap</code></li>
</ul>
</li>
<li>syntax:<ul>
<li>right bias (flatMap/map/filter работающие на правой части Either, есть из коробки в scala 2.12+)</li>
<li><code>a.asRight</code></li>
<li><code>a.asLeft</code></li>
</ul>
</li>
</ul>
<h3>MonadError</h3>
<ul>
<li>абстракция поверх Either для работы с ошибками</li>
<li>параметризирован типом монады и типом ошибки</li>
<li>операции<ul>
<li><code>.raiseError(e)</code></li>
<li><code>.handleError(a)(f)</code></li>
<li><code>.ensure(a)(e)(predicate)</code></li>
</ul>
</li>
<li>syntax<ul>
<li><code>.ensure(e)(predicate)</code></li>
</ul>
</li>
</ul>
<h3>Eval</h3>
<ul>
<li>абстракция над выполнением</li>
<li>в частности: позволяет делать стекобезопасные рекурсивные вычисления</li>
<li>операции<ul>
<li><code>.now(f)</code></li>
<li><code>.later(f)</code></li>
<li><code>.always(f)</code></li>
<li><code>.memoize</code></li>
<li><code>.defer(=&gt; Eval)</code></li>
</ul>
</li>
</ul>
<h3>Writer</h3>
<ul>
<li>сбор лога при вычислении</li>
<li>операции<ul>
<li><code>val (log, result) = writer.run</code></li>
<li><code>.mapWritten(f)</code></li>
<li><code>.bimap(f, g)</code></li>
<li><code>.mapBoth( (log, res) =&gt; ...)</code></li>
<li><code>.reset</code></li>
<li><code>.swap</code></li>
</ul>
</li>
<li>syntax:<ul>
<li><code>a.pure[T]</code> (требует Monoid[T] в implicit scope)</li>
<li><code>a.tell</code></li>
<li><code>a.writer(seq)</code></li>
</ul>
</li>
</ul>
<h3>Reader</h3>
<ul>
<li>построение цепочки операций на основе входных параметров</li>
<li>ex: DI, encoders</li>
<li>операции:<ul>
<li><code>.flatMap</code> – позволяет объединить несколько reader от одного входного значения</li>
<li><code>.map</code></li>
</ul>
</li>
</ul>
<h3>State</h3>
<ul>
<li>передача дополнительного состояния в вычисления</li>
<li>моделирование мутабельного состояния в pure functional подходе</li>
<li><code>State[S, A]</code> это <code>S =&gt; (S, A)</code></li>
<li>операции<ul>
<li><code>val (state, res) = a.run(v).value</code></li>
<li><code>a.runS(v).value</code></li>
<li><code>a.runA(v).value</code></li>
</ul>
</li>
<li>стандартные преобразования<ul>
<li><code>State.get</code></li>
<li><code>State.set</code></li>
<li><code>State.pure</code></li>
<li><code>State.inspect</code></li>
<li><code>State.modify</code></li>
</ul>
</li>
<li>синтаксис<ul>
<li>for comprehension</li>
</ul>
</li>
</ul>
<h3>Monad transformers</h3>
<ul>
<li>позволяют комбинировать монады</li>
<li>комбинация невозможна без знаний об одной из двух монад</li>
<li>например, EitherT позволяет комбинировать любую монаду с Either</li>
<li>из коробки: <code>cats.data.{OptionT, EitherT, ReaderT, WriterT, StateT, IdT}</code></li>
<li>соглашение: трансформер определяет внутреннюю монаду, а первый его тип - внешнюю. например, <code>OptionT[List, A]</code> – создаст монаду для <code>List[Option[A]]</code></li>
<li>syntax:<ul>
<li>если нужно часто определять alias для типов в стеках монад, поможет scala compiler plugin king projector. с ним можно писать так: <code>123.pure[EitherT[Option, String, ?]]</code></li>
<li><code>.pure</code></li>
<li><code>.value</code></li>
</ul>
</li>
<li>использование для реализации:<ul>
<li>многие монады реализованы через трансформеры</li>
<li><code>type ReaderT[F[_], A, B] = Kleisli[F, A, B]</code></li>
<li><code>type Writer[W, A] = WriterT[Id, W, A]</code></li>
</ul>
</li>
</ul>
<h3>Kleisli</h3>
<ul>
<li>объединение функций <code>A =&gt; F[B]</code>, <code>B =&gt; F[C]</code> в <code>A =&gt; F[C]</code></li>
</ul>
<h3>Semigroupal</h3>
<ul>
<li>объединяет два контекста</li>
<li>в литературе иногда называют Monoidal</li>
<li>операции:<ul>
<li><code>.map2</code> ... <code>.map22</code></li>
<li><code>.tuple2</code> ... <code>.tuple22</code></li>
<li><code>.contramap2</code> ... <code>.contramap22</code></li>
<li><code>.imap2</code> ... <code>.imap22</code></li>
</ul>
</li>
<li>syntax<ul>
<li><code>(a, b, c, ...).tupled</code></li>
<li><code>(a, b, c ...).mapN</code></li>
<li><code>(Monoid[A], Monoid[B], ...).imapN(toF)(fromF)</code></li>
</ul>
</li>
<li>Intellij Idea не понимает тип выражения после mapN, это <a href="https://youtrack.jetbrains.com/issue/SCL-12892">недавно поправили</a></li>
<li>Иногда получаемый результат не сразу очевиден. Например Semigroupal от двух списков будет прямое произведение (каждый с каждым), а не zip списков.</li>
</ul>
<h3>Validated</h3>
<ul>
<li>аналог Either, но с накоплением всех ошибок</li>
<li>требует Semigroup для типа ошибки</li>
<li>операции<ul>
<li><code>Validated.valid[E, A](a)</code></li>
<li><code>Validated.invalid[E, A](e)</code></li>
<li><code>Validated.catchOnly[Throwable](f)</code></li>
<li><code>Validated.catchNonFatal(f)</code></li>
<li><code>Validated.fromTry(a)</code></li>
<li><code>Validated.fromEither[E, A](a)</code></li>
<li><code>Validated.fromOption[E, A](a, e)</code></li>
<li><code>.map(f)</code></li>
<li><code>.leftMap(f)</code></li>
<li><code>.bimap(f, g)</code></li>
<li><code>.toEither</code></li>
<li><code>.withEither(f)</code></li>
<li><code>.withValidated(f)</code></li>
<li><code>.getOrElse(a)</code></li>
<li><code>.fold(f, g)</code></li>
</ul>
</li>
<li>syntax<ul>
<li><code>a.valid[E]</code></li>
<li><code>a.invalid[A]</code></li>
<li><code>.pure[Validated[F[E], A]]</code></li>
<li><code>.raiseError[Validated[F[E], A], E]</code></li>
<li><code>.tupled</code></li>
</ul>
</li>
</ul>
<h3>Apply</h3>
<ul>
<li>Semigroupal + Functor</li>
<li>альтернативный к Semigroupal способ закодировать объединение контекстов</li>
<li>операции<ul>
<li><code>.ap(f)(a)</code></li>
<li><code>.product(a, b)</code></li>
</ul>
</li>
</ul>
<h3>Applicative</h3>
<ul>
<li>Apply + pure, который позволяет создать новый Applicative instance из сырого значения</li>
<li>Monad = Applicative + FlatMap</li>
<li>операции<ul>
<li><code>.pure(a)</code></li>
</ul>
</li>
</ul>
<h3>NonEmpty*</h3>
<ul>
<li>аналоги стандартных коллекций, но имеющие строго один или более элементов</li>
<li><code>NonEmptyList</code></li>
<li><code>NonEmptyVector</code></li>
</ul>
<h3>Foldable</h3>
<ul>
<li>абстракция для foldLeft / foldRight</li>
<li>операции<ul>
<li><code>.foldLeft(a, i)(f)</code></li>
<li><code>.foldRight(a, i: Eval[B])(f): Eval[B]</code> (stack safe)</li>
<li>привычные методы коллекций, поверх foldLeft: <code>.find</code>, <code>.exists</code>, <code>.forall</code>, <code>.toList</code>, <code>.isEmpty</code>, <code>.nonEmpty</code> ...</li>
<li><code>.combineAll(a)</code> (aka <code>.fold</code>, требует Monoid)</li>
<li><code>.foldMap(a)(f)</code> (требует Monoid)</li>
<li><code>.compose(other)</code></li>
</ul>
</li>
<li>syntax:<ul>
<li>все операции доступны как синтаксис</li>
<li><code>a.foldLeft(i)(f)</code> и т. д.</li>
</ul>
</li>
</ul>
<h3>Traverse</h3>
<ul>
<li>имея набор из F[A], получить F от набора А</li>
<li>например, <code>List[Future[A]]</code> → <code>Future[List[A]]</code></li>
<li>операции<ul>
<li><code>.traverse(a)(f)</code></li>
<li><code>.sequence(a)</code></li>
</ul>
</li>
<li>syntax:<ul>
<li><code>a.traverse(f)</code></li>
<li><code>a.sequence</code></li>
</ul>
</li>
</ul>
                </div>

            </article>
            <hr/>
            <article>
                <h2><a href="https://blog.maizy.ru/posts/video-jan-oct-2016">Обзоры видео на технические темы, январь-сентябрь 2016</a></h2>
                    <div class="article-info">
<footer class="post-info">
    <div class="published">
        <time datetime="2016-10-05T00:00:00+03:00"> 05.10.2016</time>
    </div>



<div class="tags">
<i class="fa fa-tags"></i>&nbsp;
	<a href="https://blog.maizy.ru/tag/video">video</a>
        /
	<a href="https://blog.maizy.ru/tag/scala">scala</a>
</div>

</footer><!-- /.post-info -->                    </div>
                <div class="summary"><p>Каждый рабочий день, в обеденный перерыв, у меня есть 15-20 минут на просмотр видео. Читать в этот момент не удобно, это отвлекает от процедуры поглощения пищи, а видео в самый раз.</p>
<p>Впечатления от видео за январь-октябрь этого года в этом посте. В последующем планирую переодически делать такие обзоры.</p>
<p>Предыдущий похожий обзор – <a href="https://blog.maizy.ru/posts/scala-days-2015-sf">Видео со ScalaDays 2015 San Francisco</a>.</p>
<h3><a href="https://www.youtube.com/watch?v=Mw_Jnn_Y5iA">Scala Monads: Declutter Your Code With Monadic Design – Dan Rosen</a></h3>
<ul>
<li>общие слова про монады, flatmap и map</li>
<li>примеры на scalaz</li>
<li>Хороший вывод в конце - монады что-то прячут, заменяя это на типы. Option прячет boilerplate от "if non-null" logic, Validation – try/catch и т.д.</li>
</ul>
<h3><a href="https://www.youtube.com/watch?v=uKc0Gx_lPsg">The Multi-threading, Non Blocking IO – Heinz Kabutz</a></h3>
<p>Live coding сессия. Объясняется способ написать сервер: блокирующий, неблокирующий на nio, с тредами или с селекторами. Интересно.</p>
<h3><a href="https://www.youtube.com/watch?v=uZd-MvN1n4E">Scalaz: the history, the motivation, the battles, the future – Tony Morris</a></h3>
<p>Не интересно.</p>
<h3><a href="http://www.youtube.com/watch?v=Cc2QtbjUX60">Фреймворк Akka и его использование в Яндексе – Вадим Цесько</a></h3>
<ul>
<li>Интересно не сколько про саму akka, там уже некоторые вещи неактуальны для новых версий. Для себя вынес только факт того, что не стоит крутить акторы в системном дефолтном диспечере.</li>
<li>Интересно было послушать про систему в общем и узнать, как построена структура обработки данных.</li>
<li>Интересно смотреть, как это всё меняется, и меняется ли в связи с akka streams.</li>
</ul>
<h3><a href="https://www.youtube.com/watch?v=9xFfOhasiOE">CRDTs Illustrated – Arnout Engelen</a></h3>
<p>Хороший начальный обзор CRDT с наглядными схемами.</p>
<h3><a href="https://www.youtube.com/watch?v=IOiZatlZtGU">Propositions as Types – Philip Wadler</a></h3>
<ul>
<li>Известный доклад Вадлера. Стоит посмотреть и посмотреть до конца.</li>
<li>Вадлер рассказывает об истории развития теоретической базы под разными концепциями, на которых построены языки программирования.</li>
<li>Выжимка: все изобретено дважды. Сначала математиками, потом в computer science.</li>
</ul>
<h3><a href="http://www.youtube.com/watch?v=jyMIvcUxOJ0">Learning scalaz – Eugene Yokota</a></h3>
<ul>
<li>Очень поверхностный рассказ про scalaz, скорее про проблемы, которые он может решить.</li>
<li>В конце – список полезных книг и их обзор.</li>
</ul>
<h3><a href="https://engineering.twitter.com/university/videos/zipkin-at-twitter">Zipkin at Twitter – Jeff Smick</a></h3>
<p>Zipkin – система трассировки логов в распределённых сервисах.</p>
<ul>
<li>Подход интересный, в других системах я такого не видел.</li>
<li>Сложилось впечатление, что использовать за пределами твиттер-стека не удобно.</li>
</ul>
<h3><a href="https://skillsmatter.com/skillscasts/6483-keynote-scaling-intelligence-moving-ideas-forward">Scaling Intelligence: moving ideas forward – Jessica Kerr</a></h3>
<p>Про кривую изучения scala и community вокруг языка. Про то, как должна выглядеть документация и руководства, чтобы они были понятны людям с разными уровнями понимания computer science и математики, присутствующей в scala.</p>
<p>Позиция автора очень релевантна моему представлению о процессе обучения.</p>
<h3><a href="https://skillsmatter.com/skillscasts/6939-optimising-scala-for-fun-and-profit">Optimising Scala for fun and profit – Rory Graves</a></h3>
<p>Несколько простых и понятных способов понять, что сделать, чтобы scala работала быстрее. Также про магию, которая лежит за красивыми концепциями в scala, и чего это стоит для производительности.</p>
                </div>

            </article>
            <hr/>
            <article>
                <h2><a href="https://blog.maizy.ru/posts/scala-days-2015-sf">Видео со ScalaDays 2015 San Francisco</a></h2>
                    <div class="article-info">
<footer class="post-info">
    <div class="published">
        <time datetime="2015-12-09T00:00:00+03:00"> 09.12.2015</time>
    </div>



<div class="tags">
<i class="fa fa-tags"></i>&nbsp;
	<a href="https://blog.maizy.ru/tag/scala">scala</a>
        /
	<a href="https://blog.maizy.ru/tag/conference">conference</a>
</div>

</footer><!-- /.post-info -->                    </div>
                <div class="summary"><p>Заметки к некоторым видео с главной scala конференции. Все видео и слайды давно доступны на сайте <a href="https://www.parleys.com/channel/scala-days-san-francisco-2015">parleys.com</a>.</p>
<h3><a href="https://www.parleys.com/tutorial/scala-where-came-from-where-its-going">Scala - where it came from, where it's going - Martin Odersky</a></h3>
<p>Key note конференции. Советую всем, кто интересуется будущим scala и взглядом на это Мартина. Упоминали новый компилятор dotty, scala.js, scala 2.12. Кстати да, DSL для XML собираются вынести из языка в строковые интерполяторы.</p>
<h3><a href="https://www.parleys.com/tutorial/akka-http-reactive-web-toolkit">Akka HTTP: the Reactive Web Toolkit - Roland Kuhn</a></h3>
<p>Про стримы в Akka, с демонстрациями кода. Роланд начинает с соединения TCP со стримами, описывает реализации кастомных протоколов и доходит к тому, как на всём этом реализован HTTP. В ответах на вопросы к докладу упомянуто много планов по развитию стримов и HTTP в akka. Из важного я узнал, что netty внутри play планируют заменить на новый HTTP core.</p>
<h3><a href="https://www.parleys.com/tutorial/reactive-slick-database-programming">Reactive Slick for Database Programming - Stefan Zeiger</a></h3>
<p>В начале доклада капитанские вещи о том, какие проблемы есть с БД в асинхронных окружениях и как их принято решать. Затем описывается state и IO монады. Затем объяснятся как slick решает вопросы доступа к БД, представления результатов и зачем там Futures. Интересную мысль, которую я вынес, что при текущей моделе БД асинхронные драйвера, которые стали появляться, не решают проблему, так как внизу БД всё равно работает в синхронном стиле.</p>
<h3><a href="https://www.parleys.com/tutorial/type-level-programming-scala-101">Type-level Programming in Scala 101 - Joe Barnes</a></h3>
<p>Весёлая вводная в type-level программирование без углубления в незначительные на первых этапах детали. С примерами кода и тестов. Доклад в режиме ответов на вопросы, которые, к сожалению, не всегда слышно.</p>
<h3><a href="https://www.parleys.com/tutorial/function-passing-style-new-model-asynchronous-distributed-programming">Function-Passing Style, A New Model for Asynchronous and Distributed Programming - Heather Miller</a></h3>
<p>Интересный доклад о попытках написать решение, которое в некоторых случаях может использоваться как замена модели акторов. В двух словах идея в том, что стейт может жить в одном месте, а обработка его вызываться из другого, для чего по сети можно передавать лямбды, вместо данных. При этом топология решения может быть любая, как ptp, так и master-slave, например. Если я всё правильно уловил, уже есть работающий прототип.</p>
                </div>

            </article>
            <hr/>
            <article>
                <h2><a href="https://blog.maizy.ru/posts/mt8057-usb-hid-scala">Мониторинг CO2 и работа с USB на scala</a></h2>
                    <div class="article-info">
<footer class="post-info">
    <div class="published">
        <time datetime="2015-11-12T00:00:00+03:00"> 12.11.2015</time>
    </div>



<div class="tags">
<i class="fa fa-tags"></i>&nbsp;
	<a href="https://blog.maizy.ru/tag/scala">scala</a>
        /
	<a href="https://blog.maizy.ru/tag/hardware">hardware</a>
        /
	<a href="https://blog.maizy.ru/tag/ambient7">ambient7</a>
</div>

</footer><!-- /.post-info -->                    </div>
                <div class="summary"><p>Озадачился мониторингом CO2 в помещениях. Сначала смотрел на отдельные датчики, думая собрать на коленке и rPi, но потом нашёл дешёвый сборный комплект <a href="http://masterkit.ru/shop/others/dadget/1266110">Masterkit MT8057</a>. Он настолько отличный, что с удовольствием его рекламирую.</p>
<p>В результате у меня <a href="#res">получился драйвер к MT8057 на scala и stand alone утилита</a>, ниже в посте поделюсь некоторыми заметками к этой реализации.</p>
<h3>Драйвер MT8057</h3>
<p>Для MT8057 есть opensource реализация утилиты для съёма параметров от Олега Булатова написанная на C – <a href="https://github.com/dmage/co2mon">co2mon</a>. co2mon вариант хороший и рабочий, поддерживает и OS X, и Linux. Наверное, я бы справился докрутить туда выгрузку данных в InfluxDB, куда я собирался сложить все метрики, но решил пописать своих велосипедов, попрактиковаться в низкоуровневых штуках на scala и вспомнить работу с USB.</p>
<p>В первый подход взял хороший и зрелый проект <a href="http://usb4java.org/">usb4java</a>, но оказалось, что с поддержкой OS X там беда. Требуются извращения типа <a href="https://github.com/libusb/libusb/wiki/FAQ#How_can_I_run_libusb_applications_under_Mac_OS_X_if_there_is_already_a_kernel_extension_installed_for_the_device">выгрузки-загрузки kext'ов</a>, которые у меня ещё и не завелись с первого раза.</p>
<p>Во второй подход взял <a href="https://github.com/gary-rowe/hid4java">hid4java</a>, этот продукт хоть и анонсируется, как годный к production использованию, ещё достаточно сырой. Шаг влево, шаг вправо и ловишь jvm crash где-то в кишках интеграции с C-шной библиотекой. Написан через <a href="https://github.com/java-native-access/jna">JNA</a>, внутри лежат скомпилированные библиотеки для Linux x86_64, Linux ARM, OS X и ещё нескольких платформ. На OS X работает без всяких танцев с kext'ами. Из проблем – API не очень удобный, хуки вызываются из каких попало тредов, у меня это обходится с помощью обёртки с потокобезопасной очередью. Часть методов работает как бы правильно, возвращает правильные Java объекты, но при попытке что-то вызвать у этого объекта получаешь ошибку или crash, так что пришлось <a href="https://github.com/maizy/ambient7/blob/41e6b92a9ca21769d6e9c7c5a47868d1740f8b5a/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MT8057Service.scala#L99-L101">добавить костыль</a>.</p>
<p>HID это отдельный класс USB устройств, поэтому не всегда будет выбор между этими библиотеками, в частности usb4java (а вернее libusb) ничего про HID <a href="http://www.libusb.org/wiki/APIs#libusb-1.0currentAPIandimplementation">не знает и знать не собирается</a>.</p>
<h3>Scala для работы с байтами</h3>
<p>В scala всё просто и удобно. Массивы java типа <code>byte[]</code> в Scala превращаются в <code>Array[Byte]</code>. Вооружившись в добавок <code>scala.collection.JavaConversions</code> можно писать привычный scala код.</p>
<p>Внутри драйвера есть <a href="https://github.com/maizy/ambient7/blob/master/mt8057-agent/src/main/scala/ru/maizy/ambient7/mt8057agent/MessageDecoder.scala">зубодробительный код с распаковкой данных</a> от MT8057 и всё это неплохо легло в scala код, местами даже функциональный.</p>
<p><a name="res"/></p>
<h3>Результат</h3>
<p>На выходе у меня получился драйвер MT8057 и декодер к HID пакетам с данными. В отдельный артефакт я их не выделял, но при необходимости это можно сделать.</p>
<p>Про драйвер можно ничего не знать и использовать готовую утилиту <a href="https://github.com/maizy/ambient7#mt8057-agent">ambient7-mt8057-agent</a> которая из зависимостей требует только jre 1.6+ и пока умеет выводить данные в stdout/stderr (для записи в текстовый лог) или работать в интерактивном режиме с ANSI цветами в консоле. На подходе ещё возможность писать в InfluxDB. Готовый jar можно <a href="https://github.com/maizy/ambient7#download">скачать в github</a>.</p>
<p>Про InfluxDB, если удастся с ним подружиться, расскажу отдельно.</p>
                </div>

            </article>
            <hr/>
            <article>
                <h2><a href="https://blog.maizy.ru/posts/handlerbars-templates-in-scala">Шаблонизация с handlebars и json4s на scala</a></h2>
                    <div class="article-info">
<footer class="post-info">
    <div class="published">
        <time datetime="2015-10-28T00:00:00+03:00"> 28.10.2015</time>
    </div>



<div class="tags">
<i class="fa fa-tags"></i>&nbsp;
	<a href="https://blog.maizy.ru/tag/scala">scala</a>
        /
	<a href="https://blog.maizy.ru/tag/scalamoscow">scala.moscow</a>
</div>

</footer><!-- /.post-info -->                    </div>
                <div class="summary"><p>Занимаюсь неспешно своим проектом <a href="https://github.com/scala-moscow/">scala.moscow</a>. Одна из задач – примитивный генератор статических сайтов. Очень хотелось чего-то простого для шаблонизации. Думал взять mustache, но оказалось, что это уже не совсем модно-молодёжно, так как есть его расширения handlebars и hogan.</p>
<p>Handlebars мне больше приглянулся. Для scala есть нативная реализация на парсер комбинаторах
<a href="https://github.com/mwunsch/handlebars.scala">handlebars.scala</a> и её <a href="https://github.com/gilt/handlebars.scala.fork">форк</a>. По фичам scala реализация очень ограничена, в частности, нет встроенной поддержки наследования шаблонов, которая в handlebars делается не силами шаблонизатора, а силами helper'ов. В итоге взял <a href="https://github.com/jknack/handlebars.java">handlebars.java</a>, который выглядит достаточно зрелым и имеет в составе, как минимум, helper'ы <code>partial</code> и <code>block</code> для наследования и i18n.</p>
<p>После выбора шаблонизатора встал вопрос как в него загружать данные. Встроенные резолверы не удобно использовать в scala, да и хотелось чего-то более простого, чем создания пачки классов-контейнеров для данных. А что есть проще для описания примитивных структур данных, чем JSON. Для scala нашёлся отличный DSL для JSON - <a href="http://json4s.org/">json4s</a>, у которого в частности есть такой лаконичный DSL:</p>
<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.json4s.JsonDSL._</span>

<span class="k">val</span> <span class="n">data</span> <span class="k">=</span>
    <span class="o">(</span><span class="s">&quot;copyright&quot;</span> <span class="o">-&gt;</span>
      <span class="o">(</span><span class="s">&quot;year&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;2015&quot;</span><span class="o">)</span>
    <span class="o">)</span> <span class="o">~</span>
    <span class="o">(</span><span class="s">&quot;assets&quot;</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="s">&quot;path&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;/assets&quot;</span><span class="o">))</span> <span class="o">~</span>
    <span class="o">(</span><span class="s">&quot;title&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;scala.moscow&quot;</span><span class="o">)</span> <span class="o">~</span>
      <span class="o">(</span><span class="s">&quot;main&quot;</span> <span class="o">-&gt;</span>
        <span class="o">(</span><span class="s">&quot;id&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;main&quot;</span><span class="o">)</span>
      <span class="o">)</span> <span class="o">~</span>
      <span class="o">(</span><span class="s">&quot;about&quot;</span> <span class="o">-&gt;</span>
        <span class="o">(</span><span class="s">&quot;id&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;about&quot;</span><span class="o">)</span> <span class="o">~</span>
        <span class="o">(</span><span class="s">&quot;title&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;scala.moscow :: о проекте&quot;</span><span class="o">)</span>
      <span class="o">)</span>
    <span class="o">)</span>
</pre></div>


<p>Плюс к этому handlebars и задумывался для комбинации с JSON, что отражается в его синтаксисе. Плюс к этому сразу решается вопрос, где хранить статические данные, которые не нужно генерить программно –  в JSON файлах. В json4s конечно есть не только DSL, но и парсеры на основе нативной scala реализации и jackson.</p>
<p>Чтобы подружить handlebars.java и json4s DSL, написал <a href="https://github.com/scala-moscow/scala.moscow/blob/master/site-generator/src/main/scala/moscow/scala/sitegen/utils/template/JValueResolver.scala">ValueResolver</a>, идею и часть реализации подсмотрел у <a href="https://github.com/mfirry/handlebars-json4s/">handlebars-json4s</a>, но доработал её, решил часть проблем и дописал тестов. Как решу <a href="https://github.com/scala-moscow/scala.moscow/blob/4d31fad70f7bccd8097de21637f820375af41b52/site-generator/src/test/scala/moscow/scala/sitegen/tests/utils/template/JValueResolverSpec.scala#L86-L93">оставшиеся проблемы</a> планирую сделать отдельный артефакт.</p>
                </div>

            </article>
            <hr/>
            <article>
                <h2><a href="https://blog.maizy.ru/posts/akka-cluster-testing">Akka. Тестирование в общем и про тестирование кластера в частности</a></h2>
                    <div class="article-info">
<footer class="post-info">
    <div class="published">
        <time datetime="2015-09-21T00:00:00+03:00"> 21.09.2015</time>
    </div>



<div class="tags">
<i class="fa fa-tags"></i>&nbsp;
	<a href="https://blog.maizy.ru/tag/akka">akka</a>
        /
	<a href="https://blog.maizy.ru/tag/scala">scala</a>
</div>

</footer><!-- /.post-info -->                    </div>
                <div class="summary"><p>Продолжая заниматься <a href="https://github.com/maizy/akka-cluster-heartbeat">hello world'ом на akka</a> погрузился в вопрос тестирования акторов.</p>
<p>Общие вещи просты, не вижу смысла пересказывать <a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html">документацию</a>, остановлюсь только на ключевых моментах и выводах.</p>
<h3>Асинхронное vs синхронное тестирование</h3>
<p>Есть два подхода <a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Synchronous_Unit_Testing_with_TestActorRef">синхронное</a> и <a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Asynchronous_Integration_Testing_with_TestKit">асинхронное</a> тестирование. Первое в реальной жизни почти никогда не нужно, если только не хочется протестировать какие-то уж совсем внутренние кишки актора. В остальных случаях, лучше тестировать честно, отправляя и принимая ответы от акторов.</p>
<h3>TestProbe и TestActor</h3>
<p>Часть которую важно понимать. Сначала я думал, что при тестировании будет какая-то чёрная магия, которая позволит мне получать сообщения, летающие между разными акторами.</p>
<p>На деле всё проще. Внутри вашего TestCase создаётся TestProbe и TestActor, которые затем используются для запросов к акторам и анализа приходящих результатов. К сожалению, в документации сразу показывается пример с trait <code>ImplicitSender</code>, который слегка "гримирует" наличие testActor, что вызвало по началу повышенное количество wtf-per-line.</p>
<p>Соответственно <a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Built-In_Assertions">набор стандартных assert'ов</a> на самом деле вызывается у стандартного TestProbe. Конечно же таких TestProbe можно даже <a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Using_Multiple_Probe_Actors">создать несколько</a> и, например, поместить в них дополнительные специфичные вам assert'ы.</p>
<p>Отсюда же вывод, что для тестирования parent-child взаимодействия придётся вставлять между ними тестовый актор с проксированием сообщений, в документации <a href="http://doc.akka.io/docs/akka/2.3.14/scala/testing.html#Testing_parent-child_relationships">описаны способы сделать это</a>. В любом случае production код нужно немного к такому подготовить, другой вопрос, что изменения полезны и для других целей.</p>
<h3>Cluster testing</h3>
<p>С тестированием кластерных конфигурацию всё не так тривиально.</p>
<p>Для начала есть решение <a href="https://github.com/sbt/sbt-multi-jvm">multi-jvm тестирования с плагином для sbt</a>, в документации к akka описано как <a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html">это всё подружить с тестами</a>, чтобы <a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html">получить Multi Node Testing</a>. Пригодится и для других задач, когда используется просто akka remote.</p>
<p>Печалит, что нужно <a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-jvm-testing.html#multi-jvm-testing">серьёзно "испортить" конфиг sbt</a>, но, наверное, можно решить выносом таких тестов в отдельный sbt проект. Также ваша IntelliJ IDEA по понятным причинам про такие тесты ничего знать не будет, так как всё магия работает только в связке с sbt. Думаю, в ScalaIDE будет аналогично.</p>
<p>Простого способа дебажить это тоже нет. Логи не очень удобны, так как валяться в параллель со всех JVM. В идеале нужно писать обёртки, которые будут собирать их по каждой ноде отдельно.</p>
<h3>"... напоминает мне игру: "Что? Где? Когда?" называется! Непонятно, что где валяется и когда все это кончится!"</h3>
<p>Общерекомендуемый подход писать multi-jvm тесты в одном классе, который будет одинаково выполняться на всех нодах. Это обязывает постоянно следить за тем какой код и где исполняется. Например, написанный в лоб assert будет выполнен на всех нодах, часть из которых может быть ещё не присоединена к кластеру.</p>
<p>Постоянно об это спотыкался, но потом написал себе пару удобных утилиток:</p>
<div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">org.scalatest.</span><span class="o">{</span> <span class="nc">BeforeAndAfterAll</span><span class="o">,</span> <span class="nc">Matchers</span><span class="o">,</span> <span class="nc">Suite</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.cluster.Cluster</span>
<span class="k">import</span> <span class="nn">akka.cluster.ClusterEvent.</span><span class="o">{</span> <span class="nc">CurrentClusterState</span><span class="o">,</span> <span class="nc">MemberUp</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.remote.testconductor.RoleName</span>
<span class="k">import</span> <span class="nn">akka.remote.testkit.</span><span class="o">{</span> <span class="nc">MultiNodeSpec</span><span class="o">,</span> <span class="nc">MultiNodeConfig</span><span class="o">,</span> <span class="nc">MultiNodeSpecCallbacks</span> <span class="o">}</span>
<span class="k">import</span> <span class="nn">akka.testkit.ImplicitSender</span>



<span class="k">abstract</span> <span class="k">class</span> <span class="nc">MultiNodeBaseSpec</span><span class="o">(</span><span class="n">config</span><span class="k">:</span> <span class="kt">MultiNodeConfig</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">MultiNodeSpec</span><span class="o">(</span><span class="n">config</span><span class="o">)</span>
  <span class="k">with</span> <span class="nc">Suite</span>
  <span class="k">with</span> <span class="nc">BeforeAndAfterAll</span>
  <span class="k">with</span> <span class="nc">MultiNodeSpecCallbacks</span>
  <span class="k">with</span> <span class="nc">ImplicitSender</span>
  <span class="k">with</span> <span class="nc">Matchers</span>
<span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">beforeAll</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">super</span><span class="o">.</span><span class="n">beforeAll</span><span class="o">()</span>
    <span class="n">multiNodeSpecBeforeAll</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">afterAll</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">enterBarrier</span><span class="o">(</span><span class="s">&quot;before-clean-up&quot;</span><span class="o">)</span>
    <span class="n">cleanUp</span><span class="o">()</span>
    <span class="n">enterBarrier</span><span class="o">(</span><span class="s">&quot;clean-up&quot;</span><span class="o">)</span>
    <span class="n">multiNodeSpecAfterAll</span><span class="o">()</span>
    <span class="k">super</span><span class="o">.</span><span class="n">afterAll</span><span class="o">()</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">cluster</span><span class="k">:</span> <span class="kt">Cluster</span> <span class="o">=</span> <span class="nc">Cluster</span><span class="o">(</span><span class="n">system</span><span class="o">)</span>
  <span class="n">cluster</span><span class="o">.</span><span class="n">subscribe</span><span class="o">(</span><span class="n">testActor</span><span class="o">,</span> <span class="n">classOf</span><span class="o">[</span><span class="kt">MemberUp</span><span class="o">])</span>
  <span class="n">expectMsgClass</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">CurrentClusterState</span><span class="o">])</span>
  <span class="n">println</span><span class="o">(</span><span class="s">s&quot;myself address: </span><span class="si">${</span><span class="n">node</span><span class="o">(</span><span class="n">myself</span><span class="o">).</span><span class="n">address</span><span class="si">}</span><span class="s">, role: </span><span class="si">${</span><span class="n">myself</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s">&quot;</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">currentClusterNodes</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">RoleName</span><span class="o">]()</span>

  <span class="k">def</span> <span class="n">joinToCluster</span><span class="o">(</span><span class="n">nodes</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">RoleName</span><span class="o">],</span> <span class="n">seedNode</span><span class="k">:</span> <span class="kt">RoleName</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">currentClusterNodes</span> <span class="o">++=</span> <span class="n">nodes</span>
    <span class="c1">// on new nodes await events for all cluster member</span>
    <span class="n">runOn</span><span class="o">(</span><span class="n">nodes</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">cluster</span> <span class="n">join</span> <span class="n">node</span><span class="o">(</span><span class="n">seedNode</span><span class="o">).</span><span class="n">address</span>
      <span class="o">(</span><span class="n">receiveN</span><span class="o">(</span><span class="n">currentClusterNodes</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">member</span><span class="o">.</span><span class="n">address</span> <span class="o">}.</span><span class="n">toSet</span>
        <span class="n">should</span> <span class="n">contain</span> <span class="n">theSameElementsAs</span> <span class="n">currentClusterNodes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">node</span><span class="o">(</span><span class="k">_</span><span class="o">).</span><span class="n">address</span><span class="o">).</span><span class="n">toSet</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">// on existing nodes await events for only new cluster members</span>
    <span class="n">runOn</span><span class="o">((</span><span class="n">currentClusterNodes</span> <span class="o">--</span> <span class="n">nodes</span><span class="o">.</span><span class="n">toSet</span><span class="o">).</span><span class="n">toList</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">(</span><span class="n">receiveN</span><span class="o">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">MemberUp</span><span class="o">(</span><span class="n">member</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">member</span><span class="o">.</span><span class="n">address</span> <span class="o">}.</span><span class="n">toSet</span>
        <span class="n">should</span> <span class="n">contain</span> <span class="n">theSameElementsAs</span> <span class="n">nodes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">node</span><span class="o">(</span><span class="k">_</span><span class="o">).</span><span class="n">address</span><span class="o">).</span><span class="n">toSet</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="n">enterBarrier</span><span class="o">(</span><span class="s">&quot;join-&quot;</span><span class="o">+</span> <span class="n">nodes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">name</span><span class="o">).</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">runOnJoinedNodes</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">runOn</span><span class="o">(</span><span class="n">currentClusterNodes</span><span class="o">.</span><span class="n">toList</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">a</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">cleanUp</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">cluster</span><span class="o">.</span><span class="n">unsubscribe</span><span class="o">(</span><span class="n">testActor</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>


<p>В базовом spec'е выше реализовано:</p>
<ul>
<li>подписывание на события кластера</li>
<li>метод <code>joinToCluster</code> для правильного присоединения к кластеру нод</li>
<li>метод <code>runOnJoinedNodes</code> для выполнения кода на уже работающих нодах кластера, аналогичный по использованию <a href="http://doc.akka.io/docs/akka/2.3.14/dev/multi-node-testing.html#A_Multi_Node_Testing_Example">встроенному <code>runOn</code></a></li>
</ul>
<h3>Тестирование сети</h3>
<p>Есть встроенная поддержка тестирования транспорта и сети с возможностью эмуляции проблем между нодами (blackhole). При этом я надеюсь как-нибудь попробовать приспособить docker, его API и iptables для данных целей, благо multi-jvm, кажется умеет сам в тестах упаковывать тестовую ноду в jar, раскладывать через ssh+rsync, а затем запускать.</p>
<h3>Примеры</h3>
<p>Можно глянуть, что <a href="https://github.com/maizy/akka-cluster-heartbeat/tree/master/src/multi-jvm/scala">получилось у меня</a>. Много полезных примеров я обнаружил в <a href="https://github.com/akka/akka/tree/master/akka-cluster/src/multi-jvm/scala/akka/cluster">самих исходниках akka</a> и <a href="https://github.com/jboner/akka-crdt/tree/master/src/multi-jvm/scala/akka/crdt/convergent">в проекте akka crdt</a>.</p>
<h3>Вывод</h3>
<p>Тестировать akka, даже в сложных конфигурациях можно и нужно, но tooling ещё требует доработки.</p>
                </div>

            </article>
            <hr/>
            <article>
                <h2><a href="https://blog.maizy.ru/posts/fpconf-2015">FPConf 2015 - заметки на полях</a></h2>
                    <div class="article-info">
<footer class="post-info">
    <div class="published">
        <time datetime="2015-08-17T00:00:00+03:00"> 17.08.2015</time>
    </div>



<div class="tags">
<i class="fa fa-tags"></i>&nbsp;
	<a href="https://blog.maizy.ru/tag/conference">conference</a>
        /
	<a href="https://blog.maizy.ru/tag/scala">scala</a>
</div>

</footer><!-- /.post-info -->                    </div>
                    <img src="/static/images/fpconf_logo.png" alt="article featured image" class="img-responsive pull-right article-image"/>
                <div class="summary"><p>Побывал на конференции <a href="http://fpconf.ru/">FPConf</a>. Поделюсь своими мыслями, возникшими при прослушивании докладов. Я в основном сидел на втором потоке, где было про scala, UI и пр. Первый поток был преимущественно про Erlang и Haskell.</p>
<p><s>Организаторы обещали, что будет видео, надеюсь пополнить эту статью ссылкам в будущем.</s></p>
<p>Upd 09.12.2015: дополнил.</p>
<h3><a href="http://www.youtube.com/watch?v=Pu3D5GQ6UEg">Cамурайский путь молодого scala-программиста, Сергей Лобин, Sputnik.ru</a></h3>
<p>В докладе было мало про scala, больше про проблемы при разработки геокодера в Спутнике. Главный печальный для всех фанатов Scala вывод – Scala в production и них не прижилась, найти разработчиков сложно, Go разработчиков найти значительно проще.</p>
<h3><a href="http://www.youtube.com/watch?v=xd2xtQ61zKo">Макросы scala, Михаил Муцянко, JetBrains</a></h3>
<p>Хороший вводный доклад про макросы Scala от разработчика <a href="http://blog.jetbrains.com/scala/">Scala plugin в IDEA</a>.</p>
<p>Из запомнившегося:</p>
<p>Удобный способ построения AST в макросе через <a href="http://docs.scala-lang.org/overviews/quasiquotes/intro.html">Q интерполятор</a> (квазикватирование).</p>
<p>Килер фича, когда Михаил нажатием одной волшебной кнопки прямо в IDEA, показал как разворачивается макрос в Scala код. К сожалению оказалось, что это не из production версии плагина и вроде ожидать такое в ближайшее время не стоит, так как работает не всегда корректно. Очень вкусная возможность, будем ждать.</p>
<p>В 2.12 ожидается значительное улучшение в деле разработки макросов за счёт нового проекта <a href="http://scalameta.org/">ScalaMeta</a>.</p>
<p>Хорошая ссылка на изучение: What Are Macros Good For? от Евгения Бурмако <a href="http://www.youtube.com/watch?v=4Rxo_7lrb7Y">YouTube</a>, <a href="http://scalamacros.org/paperstalks/2013-07-17-WhatAreMacrosGoodFor.pdf">слайды</a>. BTW про самого Евгения и его работу над Scala макросами можно узнать в <a href="http://eax.me/eaxcast-s02e10/">EaxCast S02E10</a>.</p>
<p>Доклад рекомендую к просмотру.</p>
<h3><a href="http://www.youtube.com/watch?v=q6H7T-8GOLk">Встраивание языка в строковой интерполятор, Михаил Лиманский, ЭСК</a></h3>
<p>Хороший практический доклад, как вместо DSL порой можно обойтись интерполятором. Какие возможности, плюсы и минусы такого подхода. Можно прямо брать доклад и писать свой интерполятор как по tutorial'у.</p>
<p>В качестве домашнего задания для себя запомнил задачу реализовать интерполятор для типобезопасного форматирования строки. Хотим с <a href="http://habrahabr.ru/users/aveic/">aveic</a> попробовать независимо друг от друга реализовать это и посмотреть, что получиться.</p>
<p>Рекомендую для тех, кто интересуется темой.</p>
<h3>Lenses And Prisms, Эдвард Кметт</h3>
<p>Самый звёздный докладчик на конференции. К сожалению без знания хотя бы основ синтаксиса Haskell понять что-то было сложно. Докладчик проводил доклад в потрясающей форме - выдавая как из пулемёта кучу кода на Haskell прями в vim'е.</p>
<p>Чтобы понять что к чему, я смотрел на порт этой библиотеки на Scala - <a href="https://github.com/julien-truffaut/Monocle">Monocle</a>.</p>
<p>В общих словах – это удобный способ изменения иммутабельных структур с возможностью написания максимально абстрактных маленьких кусочков с дальнейшим комбинированием в более сложные кусочки.</p>
<p><em>Видео к сожалению не выложили.</em></p>
<h3><a href="http://www.youtube.com/watch?v=Ev6diAO2FAI">Реактивные потоки в backend-е, Алексей Романчук, 2ГИС</a></h3>
<p>Хорошая success story про использование akka streams в production. Для меня теперь это один из ответов на вопрос «где нам нужна akka?».</p>
<p>Забавные слайды с цветными "сосиками".</p>
<p>Прозвучавшее число потерь на akka streams по сравнению с голыми акторами ~10%.</p>
<p>Рекомендую всем, кому интересны akka streams.</p>
<h3><a href="http://www.youtube.com/watch?v=__PLkxx6Yko">Scala performance для сомневающихся, Роман Гребенников, Sociohub.ru</a></h3>
<p>Самый запомнившийся доклад. Покрывает сразу две темы - пару примеров того как все модные молодёжные FP штуки из scala отражаются в bytecode JVM и машинном коде, какие потери они за собой несут или не несут. А также способы самому развернуть, померить и понять как выполняется тот или иной код.</p>
<p>Вкратце про проблемы – простой pattern matching по типу параметра - также быстро как колбаса из if'ов. Есть проблемы с boxing/unboxing в Scala collection и прикладывать <a href="http://www.scala-lang.org/api/2.11.4/index.html#scala.specialized">@specialized</a> не поможет.</p>
<p>Рекомендую к просмотру.</p>
<h3>В общем</h3>
<p>Очень приятное послевкусие от конференции, не ожидал, что про FP будет так целостно. Как сказали организаторы было 180 человек.</p>
<p>Не посмотрел в живую <a href="http://www.youtube.com/watch?v=cRWrrHPrk9g">«Фронтэнд без грусти» Никиты Прокопова</a>, о котором наслышан от коллег, которые видели доклад на какой-то другой конференции. А также хочется поглядеть на <a href="http://www.youtube.com/watch?v=w8D6Ibo_TDQ">«Aрхитектура UI на основе функциональных линз» от Ильи Беда</a>.</p>
<p><s>Буду ждать видео.</s> Дождались.</p>
                </div>

            </article>
            <hr/>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row footnotes">
         <div class="col-xs-10">&copy; 2015-2018 Никита Ковалев
            &middot; Powered by <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>
            &middot; Theme <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>.         </div>
        <div class="col-xs-2">
          <p class="pull-right">
            <i class="fa fa-rss"></i>
            <a href="https://blog.maizy.ru/feeds/category/tech/rss.xml">rss</a>
          </p>
        </div>
      </div>
   </div>
</footer>





</body>
</html>
